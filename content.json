[{"title":"2020总结｜写给2021的自己","date":"2021-05-16T13:40:40.000Z","path":"2021/05/16/life/review-2020/","text":"就挺秃然的，养生口号喊起来，防止爆肝😭 引言2020是特殊的一年，地狱开端，‘活着就好’成了2020的slogon，果然今年注定是不平凡的一年。看大家到年底总会写一下年度总结，想了想，自己现在的记忆力是在逐渐衰减，还是很有必要记录一下这一年发生的事情，以此来鞭策以后的自己。 工作先总结工作吧，工作是2020一整年的大头。2019年11月12日加入的现在这家公司，怎么说呢，本来是作为iOS开发进来的，结果title是大前端开发工程师，emmmm 这其实也还好，毕竟自己当初也是想趁机了解了解前端的技术。公司前期工作氛围还是很愉快的，同事都很有趣，弹性工作制，虽然每天工作时长都10个小时以上，大小周，并没有觉得疲惫，反而觉得很充实。直到2020年后，人员开始变动，之前一直在做的app项目也终止了。开始转手小程序和前端开发，摸索到6月份时，人员再次发生变动，小组开始转向工程效能这块，主要做些基建类的工作，后续也主要在维护前端项目和迭代需求上，中途还接手了python爬虫的工作内容。这一年只能说技术深度倒没啥变化，广度倒是有一定的扩展了。在公司的角色感觉就是一块砖，哪里需要去哪里，有点晕头转向。 技术2020算是给我打开了新大门吧，接触到了很多新的技术，新语言。技术和语言接触的不少，但是真正拿下的却没有💔。 iOS RN混合开发，soucery模版代码使用，redux数据流 移动端、web端单元测试、e2e测试 CI流水线实现 docker镜像、k8s部署 angular、react前端开发技术 wepy、remax小程序开发框架 scrapy爬虫框架, mongoDB、kafka使用 GraphQL BFF层NestJS实现 A/B实验平台前后端开发（golang、mongoDB、gRPC、Ng-Alain) DDD领域驱动设计 沟通公司的流程其实是我过去所有公司中流程最完善的一家，项目开始需要经历-需求评审-故事点评估-排期-DogFooding-Demo会-提测-上线，整套流程在公司执行的算是比较完善的了，这样可以避免对工期的预估错误，以及上线之后暴露出各种问题。一定程度上可以减少开发的bug率和测试的压力。在这家公司也注重文档的编写和项目进度的跟踪，在开发过程中有问题会及时的抛出，会议也会敢于表述自己的看法，同时每两周会有举办一次技术分享，都挺锻炼人的。所以今年文档输出和语言表达能力都有一定的提升。 展望2020年虽然接触的东西多，但是都没有深入了解。2021年还是要持续保持学习，提升技术和编程思想，书在不停买，但是都搁置着😂。 停止购买新书，至少先将手上的书看完 刷算法题，leetcode上保持活跃度 尊重细节，开发中避免犯低级的细节错误 看相关源码，深入理解 生活2020因为疫情的来临，感觉过的飞快，眨眼就迎来2021，总有种错觉，除了工作，貌似2020没有留下什么明显的痕迹。但是想来还是有迹可循的，花呗账单每个月居高不下（也不知道买了啥），只能说在自己身上的投资越来越多了，希望自己能变的更好吧。 轨迹 年后回来首次经历线上办公，刚开始还好，久了发现上班时间其实更长（遇到问题放不下，会一直花时间去解决），相当于把工作带进了生活吧 年中之后公司人员开始变动，人员巨减之后，负面情绪爆棚，只能慢慢消化 跟同事组织了一次清远自驾游，漂流很嗨、很解压，清远鸡很好吃哈哈 国庆大学室友结婚（又当了一次伴娘），去了郑州、柳州，体验了一把空中飞人，行程真的是排满（人的精力是无限的，逼一逼就出来了） 斥巨资做了icl近视手术，终于摆脱了眼镜（计划是不戴眼镜之后会保持锻炼，结果不了了之） 沉浸式密逃、剧本杀体验了一次 剩下的就是不定时的ktv、聚餐了 旅行今年旅行只自驾去了一次清远漂流、泡温泉，比较远的就跑郑州（重游了下大学）、舞钢参加了婚礼，回了一趟家，其余时间一直都在深圳两点一线生活。护照上盖个戳的计划成功泡汤了。 学习断断续续，坚持不了多久又停下了😭，意志力一如既往的薄弱。本来计划考教资的，结果毫无意外延期了，还没开始就已然结束。 生活展望定几个小目标，虽然会打脸，毕竟梦想还是要有的 多读书多读书多读书（重要的事情说三遍） 夏季游泳还是要抓起来的 至少徒步一次 长途旅游至少一次（计划去重庆） 穿衣风格还是可以改变一下的，学会化妆（效果跟变脸一样的那种） 锻炼（跑步、keep都可） 使用云函数实现一个简单的小程序，并发布 结束语不管是工作还是生活，只要有突破，对于我来说就是有收获的，and一切都是为了成为更好的自己。","tags":[{"name":"Life","slug":"Life","permalink":"http://orangeschen.cn/tags/Life/"}]},{"title":"Metal实现YUV转RGB渲染视频","date":"2018-05-08T16:00:00.000Z","path":"2018/05/09/metal-yuv-to-rgb/","text":"本次例子使用的是AVFoundation提供的AVCaptureVideoDataOutput获取每一帧的CVPixelBufferRef，详细步骤就不说了，网上有很多例子，这篇文章主要是介绍Metal中实现YUV转RGB格式的一些主要步骤，和OpenGL中的步骤差不多，主要是API和着色器不同，思路是一样的，这篇文章适合熟悉OpenGL视频渲染和有Metal基础的人观看，代码就不一一注释了，主要是本人理解的也不是很深，怕误人子弟。（示例代码为横屏显示，所以看到的屏幕是横屏显示）源代码下载地址 1 首先是shader上的片元着色器转换YUV到RGB123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;metal_stdlib&gt;using namespace metal;#define YUV_SHADER_ARGS VertexOut inFrag [[ stage_in ]],\\texture2d&lt;float&gt; lumaTex [[ texture(0) ]],\\texture2d&lt;float&gt; chromaTex [[ texture(1) ]],\\sampler bilinear [[ sampler(0) ]], \\constant ColorParameters *colorParameters [[ buffer(0) ]]&#x2F;&#x2F; RGB到YUV的转换矩阵struct VertexIn&#123; packed_float3 position; packed_float4 color; packed_float2 st;&#125;;struct VertexOut&#123; float4 position [[position]]; &#x2F;&#x2F;1 float4 color; float2 st;&#125;;struct ColorParameters&#123; float3x3 yuvToRGB;&#125;;vertex VertexOut texture_vertex( const device VertexIn* vertex_array [[ buffer(0) ]], &#x2F;&#x2F;1 unsigned int vid [[ vertex_id ]]) &#123; VertexIn VertexIn &#x3D; vertex_array[vid]; VertexOut VertexOut; VertexOut.position &#x3D; float4(VertexIn.position,1); &#x2F;&#x2F;3 VertexOut.color &#x3D; VertexIn.color; VertexOut.st &#x3D; VertexIn.st; return VertexOut;&#125;fragment half4 yuv_rgb(YUV_SHADER_ARGS)&#123; float3 yuv; yuv.x &#x3D; lumaTex.sample(bilinear, inFrag.st).r; yuv.yz &#x3D; chromaTex.sample(bilinear,inFrag.st).rg - float2(0.5); return half4(half3(colorParameters-&gt;yuvToRGB * yuv),yuv.x);&#125; 2 添加纹理缓存CVMetalTextureCacheRef和纹理MTLTexture变量123CVMetalTextureCacheRef _videoTextureCache; id&lt;MTLTexture&gt; _videoTexture[2]; CVPixelBufferRef _pixelBuffer; 添加转换矩阵的接收变量 1@property (nonatomic, strong) id&lt;MTLBuffer&gt; parametersBuffer; 以下几个都是YUV转RGB的矩阵算法，给parametersBuffer赋值，拷贝到GPU中计算 12345678910111213141516171819202122232425262728293031323334353637383940414243444546_parametersBuffer &#x3D; [_device newBufferWithLength:sizeof(ColorParameters) * 2 options:MTLResourceOptionCPUCacheModeDefault]; ColorParameters matrix; simd::float3 A; simd::float3 B; simd::float3 C; &#x2F;&#x2F; 1 &#x2F;&#x2F; A.x &#x3D; 1; &#x2F;&#x2F; A.y &#x3D; 1; &#x2F;&#x2F; A.z &#x3D; 1; &#x2F;&#x2F; &#x2F;&#x2F; B.x &#x3D; 0; &#x2F;&#x2F; B.y &#x3D; -0.343; &#x2F;&#x2F; B.z &#x3D; 1.765; &#x2F;&#x2F; &#x2F;&#x2F; C.x &#x3D; 1.4; &#x2F;&#x2F; C.y &#x3D; -0.765; &#x2F;&#x2F; C.z &#x3D; 0; &#x2F;&#x2F; 2 &#x2F;&#x2F; A.x &#x3D; 1.164; &#x2F;&#x2F; A.y &#x3D; 1.164; &#x2F;&#x2F; A.z &#x3D; 1.164; &#x2F;&#x2F; &#x2F;&#x2F; B.x &#x3D; 0; &#x2F;&#x2F; B.y &#x3D; -0.392; &#x2F;&#x2F; B.z &#x3D; 2.017; &#x2F;&#x2F; &#x2F;&#x2F; C.x &#x3D; 1.596; &#x2F;&#x2F; C.y &#x3D; -0.813; &#x2F;&#x2F; C.z &#x3D; 0; &#x2F;&#x2F; 3 A.x &#x3D; 1.164; A.y &#x3D; 1.164; A.z &#x3D; 1.164; B.x &#x3D; 0; B.y &#x3D; -0.231; B.z &#x3D; 2.112; C.x &#x3D; 1.793; C.y &#x3D; -0.533; C.z &#x3D; 0; matrix.yuvToRGB &#x3D; simd::float3x3&#123;A, B, C&#125;; memcpy(self.parametersBuffer.contents, &amp;matrix, sizeof(ColorParameters)); 获取每一帧视频信息生成纹理的代码 123456789101112131415161718192021222324252627282930313233343536373839- (void)makeYUVTexture:(CVPixelBufferRef)pixelBuffer &#123; CVMetalTextureRef y_texture ; float y_width &#x3D; CVPixelBufferGetWidthOfPlane(pixelBuffer, 0); float y_height &#x3D; CVPixelBufferGetHeightOfPlane(pixelBuffer, 0); CVMetalTextureCacheCreateTextureFromImage(kCFAllocatorDefault, _videoTextureCache, pixelBuffer, nil, MTLPixelFormatR8Unorm, y_width, y_height, 0, &amp;y_texture); CVMetalTextureRef uv_texture; float uv_width &#x3D; CVPixelBufferGetWidthOfPlane(pixelBuffer, 1); float uv_height &#x3D; CVPixelBufferGetHeightOfPlane(pixelBuffer, 1); CVMetalTextureCacheCreateTextureFromImage(kCFAllocatorDefault, _videoTextureCache, pixelBuffer, nil, MTLPixelFormatRG8Unorm, uv_width, uv_height, 1, &amp;uv_texture); id&lt;MTLTexture&gt; luma &#x3D; CVMetalTextureGetTexture(y_texture); id&lt;MTLTexture&gt; chroma &#x3D; CVMetalTextureGetTexture(uv_texture); _videoTexture[0] &#x3D; luma; _videoTexture[1] &#x3D; chroma; CVBufferRelease(y_texture); CVBufferRelease(uv_texture);&#125;- (void)display:(CVPixelBufferRef)overlay &#123; if (!overlay) &#123; return; &#125; if (!_videoTextureCache) &#123; NSLog(@&quot;No video texture cache&quot;); return; &#125; [self makeYUVTexture:overlay];&#125;- (void)setVideoTexture &#123; CVMetalTextureCacheFlush(_videoTextureCache, 0); CVReturn err &#x3D; CVMetalTextureCacheCreate(kCFAllocatorDefault, NULL, _device, NULL, &amp;_videoTextureCache); if (err) &#123; NSLog(@&quot;&gt;&gt; ERROR: Could not create a texture cache&quot;); assert(0); &#125;&#125; #（最后PS： 有大神知道怎么使用Metal实现渲染到纹理的么，求指导）","tags":[{"name":"Metal","slug":"Metal","permalink":"http://orangeschen.cn/tags/Metal/"},{"name":"iOS","slug":"iOS","permalink":"http://orangeschen.cn/tags/iOS/"}]},{"title":"Metal图片渲染","date":"2018-05-08T16:00:00.000Z","path":"2018/05/09/metal-draw-picture/","text":"本章内容主要是在上一篇绘制三角形的基础上添加了图片渲染的功能，分别说明了使用Metal和MetalKit中创建纹理的方法。 1、首先修改Metal shader的着色里的内容 添加顶点输入和输出的结构体123456789101112&#x2F;&#x2F; 输入的顶点和纹理坐标 struct VertexIn &#123; packed_float3 position; packed_float2 st; &#125;;&#x2F;&#x2F; 输出顶点和纹理坐标，因为需要渲染纹理，可以不用输入顶点颜色 struct VertexOut &#123; float4 position [[position]]; float2 st; &#125;; 顶点函数和片段函数内容12345678910111213141516&#x2F;&#x2F; 添加纹理顶点坐标vertex VertexOut texture_vertex(uint vid[[vertex_id]], const device VertexIn *vertex_array[[buffer(0)]])&#123; VertexOut outVertex; VertexIn vertexIn &#x3D; vertex_array[vid]; outVertex.position &#x3D; float4(vertexIn.position, 1.0); outVertex.st &#x3D; vertexIn.st;&#x2F;&#x2F; outVertex.color &#x3D; color[vid]; return outVertex;&#125;;fragment float4 texture_fragment(VertextInOut inFrag[[stage_in]], texture2d&lt;float&gt; texas[[texture(0)]])&#123; constexpr sampler defaultSampler; float4 rgba &#x3D; texas.sample(defaultSampler, inFrag.st).rgba; return rgba;&#125;; 2、加载图片创建Metal纹理 Metal Framework中在处理贴图上使用CGImage在CGContext上draw的方法来取得图像, 但是通过draw方法绘制的图像是上下颠倒的。 首先要说的是，在iOS的不同framework中使用着不同的坐标系： UIKit － y轴向下Core Graphics(Quartz) － y轴向上OpenGL ES － y轴向上UIKit是iPhone SDK的Cocoa Touch层的核心framework，是iPhone应用程序图形界面和事件驱动的基础，它和传统windows桌面一样，坐标系是y轴向下的; Core Graphics(Quartz)一个基于2D的图形绘制引擎，它的坐标系则是y轴向上的；而OpenGL ES是iPhone SDK的2D和3D绘制引擎，它使用左手坐标系，它的坐标系也是y轴向上的，如果不考虑z轴，在 二维下它的坐标系和Quartz是一样的。 注：不知道是不是API更新等原因，有小伙伴说图片倒置的问题还是存在，经过测试，发现CGContextDrawImage绘制的图片已经不需要处理倒置的问题了，具体原因还有待证实，或者说我这些观点有误的话希望有人能详细指出 以下内容可以忽略😆当通过CGContextDrawImage绘制图片到一个context中时，如果传入的是UIImage的CGImageRef，因为UIKit和CG坐标系y轴相反，所以图片绘制将会上下颠倒。解决方法有以下几种，解决方法一：在绘制到context前通过矩阵垂直翻转坐标系解决方法二：使用UIImage的drawInRect函数，该函数内部能自动处理图片的正确方向解决方法三：垂直翻转投影矩阵,这种方法通过设置上下颠倒的投影矩阵，使得原本y轴向上的GL坐标系看起来变成了y轴向下，并且坐标原点从屏幕左下角移到了屏幕左上角。如果你习惯使用y轴向下的坐标系进行二维操作，可以使用这种方法，同时原本颠倒的图片经过再次颠倒后回到了正确的方向： 本人能力有限，对于我来说矩阵的处理还是有难度的，所以选择第二种相对简单一些的方法来解决图片上下颠倒的问题。 新建Swift文件，引入头文件123import Metalimport UIKitimport CoreGraphics 添加图片加载方法，调用makeTexture()方法生成纹理1234567891011121314151617181920212223242526272829303132var type: MTLTextureType!var texture: MTLTexture!&#x2F;&#x2F; 在处理贴图上使用CGImage在CGContext上draw的方法来取得图像, 但是通过draw方法绘制的图像是上下颠倒的，可以通过UIImage的drawInRect函数，该函数内部能自动处理图片的正确方向，生成纹理func loadIntoTextureWithDevice(device: MTLDevice, name: String, ext: String) -&gt; Bool &#123; let path &#x3D; Bundle.main.path(forResource: name, ofType: ext) if !(path !&#x3D; nil) &#123; return false &#125; let image &#x3D; UIImage(contentsOfFile: path!) let width &#x3D; (image?.cgImage)!.width let height &#x3D; (image?.cgImage)!.height let dataSize &#x3D; width * height * 4 let data &#x3D; UnsafeMutablePointer&lt;UInt8&gt;.allocate(capacity: dataSize) let colorSpace &#x3D; CGColorSpaceCreateDeviceRGB() let context &#x3D; CGContext(data: data, width: width, height: height, bitsPerComponent: 8, bytesPerRow: 4 * width, space: colorSpace, bitmapInfo: CGImageAlphaInfo.premultipliedLast.rawValue); context?.draw((image?.cgImage)!, in: CGRect(x: 0, y: 0, width: CGFloat(width), height: CGFloat(height))) &#x2F;&#x2F; 通过UIImage的drawInRect函数，该函数内部能自动处理图片的正确方向 &#x2F;&#x2F; 不知道是不是API更新了 已经不需要这一步处理图片方向了 &#x2F;&#x2F; UIGraphicsPushContext(context!); &#x2F;&#x2F; image?.draw(in: CGRect(x: 0, y: 0, width: CGFloat(width), height: CGFloat(height))) let textDes &#x3D; MTLTextureDescriptor.texture2DDescriptor(pixelFormat: .rgba8Unorm, width: Int(width), height: Int(height), mipmapped: false) type &#x3D; textDes.textureType texture &#x3D; device.makeTexture(descriptor: textDes) if !(texture !&#x3D; nil) &#123; return false &#125; texture.replace(region: MTLRegionMake2D(0, 0, Int(width), Int(height)), mipmapLevel: 0, withBytes: context!.data!, bytesPerRow: width * 4) &#x2F;&#x2F; UIGraphicsPopContext() free(data) return true&#125; MetalKit Framework则直接提供了MTKTextureLoader创建纹理 引入MetalKit头文件12import Foundationimport MetalKit MTKTextureLoader加载图片创建纹理，MTKTextureLoader中提供了异步和同步加载的方法1234567891011121314151617181920212223242526272829enum TextureError: Error &#123; case UIImageCreationError case MTKTextureLoaderError&#125;&#x2F;*----------创建Metal纹理-------------- * @param device 设备 * @param name 图片名称 * @retun MTLTexture 纹理 *&#x2F;func makeTexture(device: MTLDevice, name: String) throws -&gt; MTLTexture &#123; guard let image &#x3D; UIImage(named: name) else &#123; throw TextureError.UIImageCreationError &#125; &#x2F;&#x2F; 处理后的图片是倒置，要先将其倒置过来才能显示出正图像, 或者修改纹理坐标，将纹理坐标左上角设置为(0,0)，这一步骤可以省略 let mirrorImage &#x3D; UIImage(cgImage: (image.cgImage)!, scale: 1, orientation: UIImageOrientation.downMirrored) let scaledImage &#x3D; UIImage.scaleToSize(mirrorImage, size: image.size) do &#123; let textureLoader &#x3D; MTKTextureLoader(device: device) let textureLoaderOption:[String: NSNumber] &#x3D; [ MTKTextureLoaderOptionSRGB: false] &#x2F;&#x2F; 异步加载 &#x2F;&#x2F; try textureLoader.newTexture(with: image.cgImage!, options: textureLoaderOption, completionHandler: &#123; (&lt;#MTLTexture?#&gt;, &lt;#Error?#&gt;) in &#x2F;&#x2F; &#x2F;&#x2F; &#125;) &#x2F;&#x2F; 同步根据图片创建新的Metal纹理 &#x2F;&#x2F; Synchronously loads image data and creates a new Metal texturefrom a given bitmap image. return try textureLoader.newTexture(with: scaledImage.cgImage!, options: textureLoaderOption) &#125;&#125; 123456789 &#x2F;&#x2F; 自定义UIImage的类方法，设置图片大小extension UIImage &#123; class func scaleToSize(_ image: UIImage, size: CGSize)-&gt;UIImage &#123; UIGraphicsBeginImageContext(size) image.draw(in: CGRect(origin: CGPoint.zero, size: size)) let scaledImage &#x3D; UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return scaledImage! &#125; 3、获取纹理坐标，渲染图片 之前绘制三角形是使用顶点绘制的，这次使用索引绘制一个四边形。 添加纹理属性1var quaTexture: MTLTexture! &#x3D; nil 添加顶点buffer1var indexBuffer: MTLBuffer! &#x3D; nil 添加顶点和索引数组123456789101112131415 &#x2F;&#x2F; 3.1 在CPU创建一个浮点数数组，需要通过把它移动到一个MTLBuffer，来发送这些数据到GPU。 let vertexData:[Float] &#x3D; [&#x2F;&#x2F; 0.0, 1.0, 0.0,&#x2F;&#x2F; -1.0, -1.0, 0.0,&#x2F;&#x2F; 1.0, -1.0, 0.0 &#x2F;&#x2F;position s, t -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1, ] let indices:[Int32] &#x3D; [ 0, 1, 2, 0, 2, 3 ] 创建一个新的indexBuffer，存放索引数组123 &#x2F;&#x2F; 3.3 在GPU创建一个新的indexBuffer，存放索引数组，从CPU里输送data indexBuffer &#x3D; device.makeBuffer(bytes: indices, length: indices.count * 4, options: MTLResourceOptions(rawValue: UInt(0)))indexBuffer.label &#x3D; &quot;Indices&quot; 编译shader1234&#x2F;&#x2F; 6.1 通过调用device.newDefaultLibrary方法获得的MTLibrary对象访问到你项目中的预编译shaders,然后通过名字检索每个shaderlet defaultLibrary &#x3D; device.newDefaultLibrary() let fragmentProgram &#x3D; defaultLibrary?.makeFunction(name: &quot;texture_fragment&quot;)let vertextProgram &#x3D; defaultLibrary?.makeFunction(name: &quot;texture_vertex&quot;) 加载纹理12345678910111213&#x2F;&#x2F; 加载纹理 &#x2F;&#x2F; 1 使用Metal let loaded &#x3D; loadTntoTextureWithDevice(device: device, name: &quot;lena&quot;, ext: &quot;png&quot;) if !loaded &#123; print(&quot;Failed to load texture&quot;) &#125; quaTexture &#x3D; texture&#x2F;&#x2F; 2 使用MetalKit do &#123; quaTexture &#x3D; try makeTexture(device: device, name: &quot;lena&quot;) &#125; catch &#123; fatalError(&quot;Error: Can not load texture&quot;) &#125; 在render方法中配置渲染命令编码器，调用setFragmentTexture添加纹理，drawIndexedPrimitives根据索引数组绘制图形。123renderEncoder.setFragmentTexture(quaTexture, at: 0) &#x2F;&#x2F; 根据索引画图renderEncoder.drawIndexedPrimitives(type: .triangle, indexCount: indices.count, indexType: .uint32, indexBuffer: indexBuffer, indexBufferOffset: 0) 最终效果图如图所示，对于这些原理的东西了解还不是很深，网上的资料太少，能力有限，只能琢磨一些简单的东西。 如果对Metal感兴趣的可以下载Metal Swift Demo, GitHub上偶然看到别人写的Demo，里面有纹理和矩阵，ModelIO和MetalKit的结合使用等例子。 最后献上Demo例子","tags":[{"name":"Metal","slug":"Metal","permalink":"http://orangeschen.cn/tags/Metal/"},{"name":"iOS","slug":"iOS","permalink":"http://orangeschen.cn/tags/iOS/"}]},{"title":"Metal入门（使用Metal画一个三角形）","date":"2018-05-01T16:00:00.000Z","path":"2018/05/02/metal-learn-base/","text":"学习使用苹果GPU加速3D绘图的新API:MetalMetal和OpenGL ES相似，它也是一个底层API，负责和3D绘图硬件交互。它们之间的不同在于，Metal不是跨平台的, Metal 是用 Objective-C 编 写的，基于 Foundation，使用 GCD 在 CPU 和 GPU 之间保持同步。与之相反的，它设计的在苹果硬件上运行得极其高效，与OpenGL ES相比，它提供了更快的速度和更低的开销。它是一个GPU上一个简单的封装，所以能够完成几乎所有事情，像在屏幕上渲染一个精灵（sprite）或者是一个3D模型。但你要编写完成这些事情的所有代码。这样麻烦的代价是，你拥有了GPU的力量和控制。优点：1、使硬件达到运行效率的峰值：因为Metal非常底层，它允许你使硬件达到运行效率的峰值，对你的游戏如何运行有着完全的控制。2、这是一个很好的学习经历：学习Metal教导你很多关于3D绘图编程的概念，编写你自己的游戏引擎，以及高层(higher level)游戏框架如何运作。 关于metal详细的介绍可参考: 以下是使用Metal和Swift来创建一个有基本脉络的应用：画一个简单的三角形。注意：Metal应用不能跑在iOS模拟器上，它们需要一个设备，设备上装载着苹果A7芯片或者更新的芯片。所以需要一台这样的设备(iPhone 5S,iPad Air,iPad mini2)来完成代码的测试。打开Xcode 通过iOS\\Application\\Single View Application template创建一个新的项目。使用TriangleSwift作为项目名称，设置开发语言为Swift，设置设备为通用设备(Universal)。点击Next，选择一个目录，点击Create。有七个步骤来设置metal：1 创建一个MTLDevice2 创建一个CAMetalLayer3 创建一个Vertex Buffer4 创建一个Vertex Shader5 创建一个Fragment Shader6 创建一个Render Pipeline7 创建一个Command Queue 1 创建一个MTLDevice使用Metal你要做的第一件事就是获取一个MTLDevice的引用。为了完成这点，打开ViewController.swift 并添加下面的import语句 1import Metal 导入了Metal框架，所以你能够使用Metal的类（像这文件中的MTLDevice）。接着，在ViewController类中添加以下属性：在viewDidLoad函数内初始化这个属性 12&#x2F;&#x2F; 1、创建一个MTLDevice, 你可以把一个MTLDevice想象成是你和CPU的直接连接。你将通过使用MTLDevice创建所有其他你需要的Metal对象（像是command queues，buffers，textures）。var device: MTLDevice! &#x3D; nil 2 创建一个CAMetalLayer在iOS里，你在屏幕上看见的所有东西，被一个CALayer所承载。存在不同特效的CALayer的子类，比如：渐变层(gradient layers)、形状层（shapelayers）、重复层(replicator layers) 等等。如果你想要用Metal在屏幕上画一些东西，你需要使用一个特别的CALayer子类，CAMetalLayer。因为CAMetalLayer是QuartzCore框架的部分，而不是Metal框架里的，首先在这个文件的上方添加import语句 1import QuartzCore 把新属性添加到类中： 12&#x2F;&#x2F; 2、创建一个CAMetalLayervar metalLayer: CAMetalLayer! &#x3D; nil 设置metalLayer 123456789101112131415&#x2F;&#x2F; 2.1 创建CAMetalLayermetalLayer &#x3D; CAMetalLayer()&#x2F;&#x2F; 2.2 必须明确layer使用的MTLDevice，简单地设置早前获取的devicemetalLayer.device &#x3D; device&#x2F;&#x2F; 2.3 把像素格式（pixel format）设置为BGRA8Unorm，它代表&quot;8字节代表蓝色、绿色、红色和透明度，通过在0到1之间单位化的值来表示&quot;。这次两种用在CAMetalLayer的像素格式之一，一般情况下你这样写就可以了。metalLayer.pixelFormat &#x3D; .bgra8Unorm&#x2F;&#x2F; 2.4 苹果鼓励将framebufferOnly设置为true，来增强表现效率。除非你需要对从layer生成的纹理（textures）取样，或者你需要在layer绘图纹理(drawable textures)激活一些计算内核，否则你不需要设置。（大部分情况下你不用设置）metalLayer.framebufferOnly &#x3D; true&#x2F;&#x2F; 2.5 把layer的frame设置为view的framemetalLayer.frame &#x3D; view.layer.framevar drawableSize &#x3D; self.view.bounds.sizedrawableSize.width *&#x3D; self.view.contentScaleFactordrawableSize.height *&#x3D; self.view.contentScaleFactormetalLayer.drawableSize &#x3D; drawableSizeview.layer.addSublayer(metalLayer) 3 创建一个Vertex Buffer创建一个缓冲区。在你的类中添加下列的常量属性 12345678&#x2F;&#x2F; 3、创建一个Vertex Buffervar vertexBuffer: MTLBuffer! &#x3D; nil&#x2F;&#x2F; 3.1 在CPU创建一个浮点数数组，需要通过把它移动到一个MTLBuffer，来发送这些数据到GPU。let vertexData:[Float] &#x3D; [ 0.0, 1.0, 0.0, -1.0, -1.0, 0.0, 1.0, -1.0, 0.0] 在MTLDevice上调用makeBuffer(bytes:, length:, options:)，在GPU创建一个新的buffer，从CPU里输送data。options不能为空。 1234&#x2F;&#x2F; 3.2 获取vertex data的字节大小。你通过把元素的大小和数组元素个数相乘来得到let dataSize &#x3D; vertexData.count * 4&#x2F;&#x2F; 3.3 在GPU创建一个新的buffer，从CPU里输送datavertexBuffer &#x3D; device.makeBuffer(bytes: vertexData, length: dataSize, options: MTLResourceOptions(rawValue: UInt(0))) 4 创建一个Vertex Shader你之前创建的顶点将成为接下来写的一个叫vertext shader的小程序的输入。一个vertex shader 是一个在GPU上运行的小程序，它由像c++的一门语言编写，那门语言叫做Metal Shading Language。一个vertex shader被每个顶点调用，它的工作是接受顶点的信息（如：位置和颜色、纹理坐标），返回一个潜在的修正位置（可能还有别的相关信息）点击File\\New\\File，选择iOS\\Source\\Metal File，然后点击Next。输入Shader.metal作为文件名，然后点击Create。 1234567891011121314&#x2F;&#x2F; 一个vertex shader被每个顶点调用，它的工作是接受顶点的信息（如：位置和颜色、纹理坐标），返回一个潜在的修正位置（可能还有别的相关信息）#include &lt;metal_stdlib&gt;using namespace metal;&#x2F;** * 1、所有的vertex shaders必须以关键字vertex开头。函数必须至少返回顶点的最终位置——你通过指定float4（一个元素为4个浮点数的向量）。然后你给一个名字给vetex shader，以后你将用这个名字来访问这个vertex shader。 * 2、vertex shader会接受一个名叫vertex_id的属性的特定参数，它意味着它会被vertex数组里特定的顶点所装入。 * 3、一个指向一个元素为packed_float4(一个向量包含4个浮点数)的数组的指针，如：每个顶点的位置。这个 [[ ... ]] 语法被用在声明那些能被用作特定额外信息的属性，像是资源位置，shader输入，内建变量。这里你把这个参数用 [[ buffer(0) ]] 标记，来指明这个参数将会被在你代码中你发送到你的vertex shader的第一块buffer data所遍历。 * 4、基于vertex id来检索vertex数组中对应位置的vertex并把它返回。向量必须为一个float4类型vertex float4 basic_vertex ( constant packed_float3* vertex_array[[buffer(0)]], unsigned int vid[[vertex_id]])&#123; return float4(vertex_array[vid], 1.0);&#125; *&#x2F; 5 创建一个Fragment Shader完成vertex shader后，另一个shader，它被每个在屏幕上的fragment(think pixel)调用，它就是fragment shader。fragment shader通过内插(interpolating)vertex shader的输出来获得自己的输入。 1234567&#x2F;* 1. 所有fragment shaders必须以fragment关键字开始。这个函数必须至少返回fragment的最终颜色——你通过指定half4（一个颜色的RGBA值）来完成这个任务。注意，half4比float4在内存上更有效率，因为，你写入了更少的GPU内存。 2. 这里你返回(0.6,0.6,0.6,0.6)的颜色，也就是灰色。 *&#x2F;fragment half4 basic_fragment() &#123; return half4(0.6);&#125; 6 创建一个Render Pipeline现在你已经创建了一个vertex shader和一个fragment shader，你需要组合它们（加上一些配置数据）到一个特殊的对象，它名叫render pipeline。Metal的渲染器（shaders）是预编译的，render pipeline 配置会在你第一次设置它的时候被编译，所以所有事情都极其高效。首先在ViewController.swift里添加一个属性： 12&#x2F;&#x2F; 6、创建一个Render Pipelinevar pipelineState: MTLRenderPipelineState! &#x3D; nil 在viewDidLoad方法最后添加如下代码： 12345678&#x2F;&#x2F; 6.1 通过调用device.newDefaultLibrary方法获得的MTLibrary对象访问到你项目中的预编译shaders,然后通过名字检索每个shader let defaultLibrary &#x3D; device.newDefaultLibrary() let fragmentProgram &#x3D; defaultLibrary?.makeFunction(name: &quot;basic_fragment&quot;) let vertextProgram &#x3D; defaultLibrary?.makeFunction(name: &quot;basic_vertex&quot;) &#x2F;&#x2F; 6.2 这里设置你的render pipeline。它包含你想要使用的shaders、颜色附件（color attachment）的像素格式(pixel format)。（例如：你渲染到的输入缓冲区，也就是CAMetalLayer） let pipelineStateDescriptor &#x3D; MTLRenderPipelineDescriptor() pipelineStateDescriptor.vertexFunction &#x3D; vertextProgram pipelineStateDescriptor.fragmentFunction &#x3D; fragmentProgram pipelineStateDescriptor.colorAttachments[0].pixelFormat &#x3D; .bgra8Unorm 7 创建一个Command Queue你需要做的最终的设置步骤，是创建一个MTLCommandQueue。把这个想象成是一个列表装载着你告诉GPU一次要执行的命令。要创建一个command queue，简单地添加一个属性： 12&#x2F;&#x2F; 7、创建一个Command Queuevar commandQueue: MTLCommandQueue! &#x3D; nil 把下面这行添加到viewDidLoad中： 12&#x2F;&#x2F; 7.1 初始化commandQueuecommandQueue &#x3D; device.makeCommandQueue() 预设置的代码到这里完成了。接下来就是渲染三角形了，它将需要在五个步骤来完成：1 创建一个Display link。2 创建一个Render Pass Descriptor3 创建一个Command Buffer4 创建一个Render Command Encoder5 提交Command Buffer的内容注意：理论上这个应用实际上不需要每帧渲染，因为三角形被绘制之后不会动。但是，大部分应用会有物体的移动，所以我们会那样做。 1 创建一个Display link在iOS平台上，通过CADisplayLink 类，可以创建一个函数在每次设备屏幕刷新的时候被调用，这样你就可以重绘屏幕。为了使用它，在类里添加一个新的属性： 12&#x2F;&#x2F; 8、创建一个Display Linkvar timer: CADisplayLink! &#x3D; nil 初始化timer 123&#x2F;&#x2F; 8.1 初始化 timer，设置timer，让它每次刷新屏幕的时候调用一个名叫drawloop的方法timer &#x3D; CADisplayLink(target: self, selector: #selector(ViewController.drawloop))timer.add(to: RunLoop.main, forMode: RunLoopMode.defaultRunLoopMode) 渲染的代码在render()中实现 12345678func render() &#123; &#x2F;&#x2F;TODO&#125;func drawloop() &#123; self.render() &#125; 2 创建一个Render Pass Descriptor123456789&#x2F;&#x2F; metal layer上调用nextDrawable() ，它会返回你需要绘制到屏幕上的纹理(texture)let drawable &#x3D; metalLayer.nextDrawable()&#x2F;&#x2F; 8、创建一个Render Pass Descriptor，配置什么纹理会被渲染到、clear color，以及其他的配置let renderPassDesciptor &#x3D; MTLRenderPassDescriptor()renderPassDesciptor.colorAttachments[0].texture &#x3D; drawable?.texture&#x2F;&#x2F; 设置load action为clear，也就是说在绘制之前，把纹理清空renderPassDesciptor.colorAttachments[0].loadAction &#x3D; .clear&#x2F;&#x2F; 绘制的背景颜色设置为绿色renderPassDesciptor.colorAttachments[0].clearColor &#x3D; MTLClearColorMake(0.0, 0.8, 0.5, 1.0) 3 创建一个Command Buffer一个command buffer包含一个或多个渲染指令（render commands）。 123&#x2F;&#x2F; 9、创建一个Command Buffer&#x2F;&#x2F; 你可以把它想象为一系列这一帧想要执行的渲染命令。注意在你提交command buffer之前，没有事情会真正发生，这样给你对事物在何时发生有一个很好的控制。let commandBuffer &#x3D; commandQueue.makeCommandBuffer() 4 创建一个渲染命令编码器(Render Command Encoder)12345678910111213141516171819 &#x2F;&#x2F; 10、创建一个渲染命令编码器(Render Command Encoder) &#x2F;&#x2F; 创建一个command encoder，并指定你之前创建的pipeline和顶点 let renderEncoder &#x3D; commandBuffer.makeRenderCommandEncoder(descriptor: renderPassDesciptor) renderEncoder.setRenderPipelineState(pipelineState) renderEncoder.setVertexBuffer(vertexBuffer, offset: 0, at: 0) &#x2F;** 绘制图形 - parameter type: 画三角形 - parameter vertexStart: 从vertex buffer 下标为0的顶点开始 - parameter vertexCount: 顶点数 - parameter instanceCount: 总共有1个三角形 *&#x2F; renderEncoder.drawPrimitives(type: .triangle, vertexStart: 0, vertexCount: 3, instanceCount: 1) &#x2F;&#x2F; 完成后，调用endEncoding() renderEncoder.endEncoding()&#96;&#96;&#96; ##### 5 提交Command Buffer // 保证新纹理会在绘制完成后立即出现 commandBuffer.present(drawable!) // 提交事务(transaction), 把任务交给GPU commandBuffer.commit()##### 学习资料： • 苹果Metal[开发者文档](https://developer.apple.com/metal/)，有很多文档、录像、样例代码的链接。 • 苹果的Metal[编程指导](https://developer.apple.com/library/prerelease/ios/documentation/Miscellaneous/Conceptual/MTLProgGuide/Introduction/Introduction.html) • 苹果的Metal [Shading Language 指导](https://developer.apple.com/library/prerelease/ios/documentation/Metal/Reference/MetalShadingLanguageGuide/Introduction/Introduction.html) • [WWDC2014 Metal录像](https://developer.apple.com/videos/wwdc/2014/)","tags":[{"name":"Metal","slug":"Metal","permalink":"http://orangeschen.cn/tags/Metal/"},{"name":"iOS","slug":"iOS","permalink":"http://orangeschen.cn/tags/iOS/"}]},{"title":"iOS-private-api-checker私有API检测工具使用详细步骤","date":"2018-04-01T16:00:00.000Z","path":"2018/04/02/private-api-checker/","text":"iOS-private-api-checker私有API检查详细步骤（涉及到 Python、Flask、sqlite 环境）1、下载iOS-private-api-checker-master https://github.com/hustcc/iOS-private-api-checker 2、下载已经build好的ios_private.db库(本人能力有限，不会build，这个是大神build好的，sdk7.0版本，不是最新的，所以有些私有库查不出来(PS: 或者有些已经公开的库检测为私有库！！详情请看上面的链接，github上有教程，写这篇文章主要是想尝试一下如何使用这个工具，准确性不敢保证)，github上有教程，有能力的可以自己build^^)，将 ios_private.db 放入到项目的根目录，主要修改可写权限； （备注：ios_private.db 下载地址： 链接: https://pan.baidu.com/s/1d7YlSa 密码: fimx） 3、在根目录创建一个 tmp 目录（如果没有的话，注意修改可写权限），或者将tmp的文件夹的权限设置为777，先进terminal，然后输入Wally的命令，后面添加你的目录名。 1$ sudo chmod -R 777 目录名 4、在终端输入sqlite3 , 出现这个表示已经安装了sqlite，没有则参考 http://www.runoob.com/sqlite/sqlite-installation.html 进行安装 安装sqlite5、配置flask环境 5.1 Mac系统已经默认安装好了Python 2.7 5.2 安装python的包管理器pip ，先下载 get-pip.py ： https://bootstrap.pypa.io/get-pip.py 执行安装命令 1$ sudo python get-pip.py 5.3 安装virtualenv，virtualenv 为每个不同项目提供一份 Python 安装。它并没有真正安装多个 Python 副本，但是它确实提供了一种巧妙的方式来让各项目环境保持独立。 1$ sudo pip install virtualenv 5.4 开始配置flask环境 1234567891011进到项目目录$ cd 项目路径创建flask文件夹$ virtualenv flask$ cd flask激活环境$ source bin/activate安装flask$ pip install flask回到根目录$ cd - 6 、安装 macholib 1$ pip install macholib 7、最后运行 run_web（或者 ） 1$ python run_web.py 在浏览器中输入127.0.0.1:9527 将ipa拖入上传框等待即可看到检查结果","tags":[{"name":"iOS","slug":"iOS","permalink":"http://orangeschen.cn/tags/iOS/"}]},{"title":"Hello World","date":"2017-11-08T13:40:40.000Z","path":"2017/11/08/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]