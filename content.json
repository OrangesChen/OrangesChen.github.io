[{"title":"Flutter 内核源码解析一Flutter 启动篇","date":"2022-11-02T06:45:22.000Z","path":"2022/11/02/flutter/flutter_source_1/","text":"Flutter engine 源码编译，注意 Flutter Framework 对应的 engine 版本和源码的 engine 版本要保持一致。假设你已经成功编译源码，以下为 Flutter 3.0 对应的版本源码，若你使用的是其他版本的，源码可能会存在一些差异。 Flutter 源码目录结构 开始这篇文章前，首先我们要明确的是，Framework 源码位于 flutter/flutter 中，通过 git clone [https://github.com/flutter/flutter.git](https://github.com/flutter/flutter.git) -b stable获取的，开发过程中断点调试的源码指的就是这个项目的，后续相关路径以 flutter 表示该目录；而 Engine 和 Embedder 的源码位于通过源码编译获取到的源码 flutter_source/src/flutter 目录中，后续相关路径以 engine 表示该目录。 以下为 Framework 源码实现，开发者接触到的代码层，flutter 目录如下图所示： flutter 源码结构 bin/internal 源码结构 flutter/packages 源码结构 其中Flutter SDK 源码指的是 Dart 实现的 Framework 层的源码。以下则为 depot_tools 获取到的 engine 目录，其中包含了 Engine 和 Embedder 层的相关实现。 flutter/engine 目录结构 需要先使用 ./flutter/tools/gn 生成构建所需的元文件，再使用 ninja 构建出最终的产物，构建出对应平台的源码。 ./flutter/tools/gn 和 ninja 工具构建不同平台的产物 hot_debug_unopt 的作用是构建 flutter 工程，生成 Dart Kernel 或者特定平台的 AOT 文件，能在 x86 架构的 PC 设备上生成 ARM 架构的机器码，生成构建 Flutter Engine 所需的元文件。ios_debug_unopt/android_denug_unopt存放最终构建出的 Engine 和 Embedder 产物，项目里面 compile_commands.json 存储了 Engine 中代码的交叉索引，后续源码调试需要使用到这个文件。 ios_debug_unopt 源码结构，engine 源码调试的路径 Flutter 源码调试Framework 源码Framework 源码调试很简单，在 flutter 项目中直接设置断点就能跳转到对应的源码文件地址查看。 Engine/Embedder 源码1flutter run ios --local-engine=ios_debug_unopt --local-engine-src-path=/Volumes/TSB\\ 1/OpenCode/engine/src 运行成功后，iOS 项目 Generated.xcconfig 配置 FLUTTER_ENGINE、LOCAL_ENGINE 更新为 Flutter Engine 源码地址， 将 LOCAL_ENGINE 源码 flutter_engine.xcodeproj拖到项目中 flutter_engine.xcodeproj 项目里设置断点，运行代码，则可开始调试 Engine/Embedder 源码 Flutter 启动流程Embedder 是 Flutter 接入原生平台的关键，位于整个 Flutter 架构底层，负责 Engine 的创建、管理与销毁，同时也为 Engine 提供绘制 UI 接口。在 Embedder 中，iOS 端的 FlutterViewController 和 Android 端的 FlutterActivity、FlutterFragment 是开发者最常接触的类。 FlutterViewController 源码解析FlutterViewController 中持有两个关键的对象 FlutterView 和 FlutterEngine，FlutterEngine 负责 Engine 在 Embedder 中的调用和管理，FlutterView 则负责 Engine 中 UI 数据的上屏显示。 1234567891011121314151617181920212223242526272829303132@implementation FlutterViewController &#123; std::unique_ptr&lt;fml::WeakPtrFactory&lt;FlutterViewController&gt;&gt; _weakFactory; // flutterEngine fml::scoped_nsobject&lt;FlutterEngine&gt; _engine; // We keep a separate reference to this and create it ahead of time because we want to be able to // set up a shell along with its platform view before the view has to appear. // flutterView fml::scoped_nsobject&lt;FlutterView&gt; _flutterView; // 闪屏 fml::scoped_nsobject&lt;UIView&gt; _splashScreenView; // flutterView 渲染回调 fml::ScopedBlock&lt;void (^)(void)&gt; _flutterViewRenderedCallback; // 设备方向 UIInterfaceOrientationMask _orientationPreferences; // 设备 statusBar 样式 UIStatusBarStyle _statusBarStyle; flutter::ViewportMetrics _viewportMetrics; BOOL _initialized; BOOL _viewOpaque; BOOL _engineNeedsLaunch; fml::scoped_nsobject&lt;NSMutableSet&lt;NSNumber*&gt;&gt; _ongoingTouches; // This scroll view is a workaround to accommodate iOS 13 and higher. There isn't a way to get // touches on the status bar to trigger scrolling to the top of a scroll view. We place a // UIScrollView with height zero and a content offset so we can get those events. See also: // https://github.com/flutter/flutter/issues/35050 fml::scoped_nsobject&lt;UIScrollView&gt; _scrollView; fml::scoped_nsobject&lt;UIHoverGestureRecognizer&gt; _hoverGestureRecognizer API_AVAILABLE(ios(13.4)); fml::scoped_nsobject&lt;UIPanGestureRecognizer&gt; _panGestureRecognizer API_AVAILABLE(ios(13.4)); fml::scoped_nsobject&lt;UIView&gt; _keyboardAnimationView; MouseState _mouseState;&#125; FlutterViewController 实现 FlutterViewResponder 协议，处理触摸事件 1234567891011@protocol FlutterViewResponder &lt;NSObject&gt;@property(nonatomic, strong) UIView* view;- (void)touchesBegan:(NSSet*)touches withEvent:(UIEvent*)event;- (void)touchesMoved:(NSSet*)touches withEvent:(UIEvent*)event;- (void)touchesEnded:(NSSet*)touches withEvent:(UIEvent*)event;- (void)touchesCancelled:(NSSet*)touches withEvent:(UIEvent*)event;- (void)touchesEstimatedPropertiesUpdated:(NSSet*)touches;@end 可以看到初始化方式有两种，其本质上是一样的，以下这个构造方法是为了在存在多个 FlutterViewController 的情况下复用 FlutterEngine 对象。 12345678910111213141516171819202122232425262728293031323334- (instancetype)initWithEngine:(FlutterEngine*)engine nibName:(nullable NSString*)nibName bundle:(nullable NSBundle*)nibBundle &#123; NSAssert(engine != nil, @\"Engine is required\"); self = [super initWithNibName:nibName bundle:nibBundle]; if (self) &#123; _viewOpaque = YES; if (engine.viewController) &#123; FML_LOG(ERROR) &lt;&lt; \"The supplied FlutterEngine \" &lt;&lt; [[engine description] UTF8String] &lt;&lt; \" is already used with FlutterViewController instance \" &lt;&lt; [[engine.viewController description] UTF8String] &lt;&lt; \". One instance of the FlutterEngine can only be attached to one \" \"FlutterViewController at a time. Set FlutterEngine.viewController \" \"to nil before attaching it to another FlutterViewController.\"; &#125; // 初始化或者替换当前的 FlutterEngine _engine.reset([engine retain]); _engineNeedsLaunch = NO; // 初始化或者替换当前的 FlutterView _flutterView.reset([[FlutterView alloc] initWithDelegate:_engine opaque:self.isViewOpaque]); _weakFactory = std::make_unique&lt;fml::WeakPtrFactory&lt;FlutterViewController&gt;&gt;(self); // 初始化正在发生的手势集合 _ongoingTouches.reset([[NSMutableSet alloc] init]); /** 1. 设置 UIInterfaceOrientationMask 和 UIStatusBarStyle 2. 添加一些列通知 Application 生命周期、键盘事件、Accessibility 的事件等 */ [self performCommonViewControllerInitialization]; // 将 FlutterViewController 设置给 FlutterEngine [engine setViewController:self]; &#125; return self;&#125; ViewController 初始化设置，添加通知消息订阅 这三个接口允许我们对 Dart 的 Navigator 直接进行操作，通过 Platform Channel 实现 1234567891011- (void)setInitialRoute:(NSString*)route &#123; [[_engine.get() navigationChannel] invokeMethod:@\"setInitialRoute\" arguments:route];&#125;- (void)popRoute &#123; [[_engine.get() navigationChannel] invokeMethod:@\"popRoute\" arguments:nil];&#125;- (void)pushRoute:(NSString*)route &#123; [[_engine.get() navigationChannel] invokeMethod:@\"pushRoute\" arguments:route];&#125; 加载 view 123456789101112131415161718192021- (void)loadView &#123; // 初始化并创建 view，存在返回，不存在则创建 self.view = GetViewOrPlaceholder(_flutterView.get()); self.view.multipleTouchEnabled = YES; self.view.autoresizingMask = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight; // 加载闪屏页面 内部会会判断是否加载闪屏页 [self installSplashScreenViewIfNecessary]; // 初始化 scrollView UIScrollView* scrollView = [[UIScrollView alloc] init]; scrollView.autoresizingMask = UIViewAutoresizingFlexibleWidth; // The color shouldn't matter since it is offscreen. scrollView.backgroundColor = UIColor.whiteColor; scrollView.delegate = self; // This is an arbitrary small size. // 设置任意的小尺寸 static constexpr CGFloat kScrollViewContentSize = 2.0; scrollView.contentSize = CGSizeMake(kScrollViewContentSize, kScrollViewContentSize); // This is an arbitrary offset that is not CGPointZero. scrollView.contentOffset = CGPointMake(kScrollViewContentSize, kScrollViewContentSize); [self.view addSubview:scrollView]; _scrollView.reset(scrollView);&#125; 12345678910111213141516171819- (void)installSplashScreenViewIfNecessary &#123; // Show the launch screen view again on top of the FlutterView if available. // This launch screen view will be removed once the first Flutter frame is rendered. // 当首帧 Flutter View 渲染成功后，则将闪屏页面移除 if (_splashScreenView &amp;&amp; (self.isBeingPresented || self.isMovingToParentViewController)) &#123; [_splashScreenView.get() removeFromSuperview]; _splashScreenView.reset(); return; &#125; // Use the property getter to initialize the default value. UIView* splashScreenView = self.splashScreenView; if (splashScreenView == nil) &#123; return; &#125; splashScreenView.frame = self.view.bounds; // 加载闪屏页 [self.view addSubview:splashScreenView];&#125; SplashScreenView 闪屏获取，属性 getter 方法实现，实现比较简单，源码就不显示出来了 Surface 创建和销毁 12345678910111213141516171819202122232425#pragma mark - Surface creation and teardown updates- (void)surfaceUpdated:(BOOL)appeared &#123; if (!_engine) &#123; return; &#125; // NotifyCreated/NotifyDestroyed are synchronous and require hops between the UI and raster // thread. // NotifyCreated/NotifyDestroyed 是同步的，需要在 UI 和 raster 线程切换 if (appeared) &#123; // surface 创建 [self installFirstFrameCallback]; [_engine.get() platformViewsController]-&gt;SetFlutterView(_flutterView.get()); [_engine.get() platformViewsController]-&gt;SetFlutterViewController(self); [_engine.get() iosPlatformView]-&gt;NotifyCreated(); &#125; else &#123; // surface 销毁 self.displayingFlutterUI = NO; [_engine.get() iosPlatformView]-&gt;NotifyDestroyed(); [_engine.get() platformViewsController]-&gt;SetFlutterView(nullptr); [_engine.get() platformViewsController]-&gt;SetFlutterViewController(nullptr); &#125;&#125; UIViewController、UIApplication 生命周期监听 原生生命周期和 Flutter 中 AppLifecycleState 的对应关系 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748- (void)viewDidDisappear:(BOOL)animated &#123; TRACE_EVENT0(\"flutter\", \"viewDidDisappear\"); if ([_engine.get() viewController] == self) &#123; // 停止 vsync 刷新 [self invalidateDisplayLink]; // // 确保 `physical_view_inset_bottom` 是目标值。 [self ensureViewportMetricsIsCorrect]; // 停止 surface 更新 [self surfaceUpdated:NO]; [[_engine.get() lifecycleChannel] sendMessage:@\"AppLifecycleState.paused\"]; // 移除正在执行的手势事件 [self flushOngoingTouches]; [_engine.get() notifyLowMemory]; &#125; [super viewDidDisappear:animated];&#125;- (void)flushOngoingTouches &#123; // 获取正在执行的所有手势事件 创建假的 PointerData 包装成 packet 结构体 if (_engine &amp;&amp; _ongoingTouches.get().count &gt; 0) &#123; auto packet = std::make_unique&lt;flutter::PointerDataPacket&gt;(_ongoingTouches.get().count); size_t pointer_index = 0; // If the view controller is going away, we want to flush cancel all the ongoing // touches to the framework so nothing gets orphaned. for (NSNumber* device in _ongoingTouches.get()) &#123; // Create fake PointerData to balance out each previously started one for the framework. flutter::PointerData pointer_data = [self generatePointerDataForFake]; // 操作类型为取消 pointer_data.change = flutter::PointerData::Change::kCancel; pointer_data.device = device.longLongValue; pointer_data.pointer_identifier = 0; // Anything we put here will be arbitrary since there are no touches. pointer_data.physical_x = 0; pointer_data.physical_y = 0; pointer_data.physical_delta_x = 0.0; pointer_data.physical_delta_y = 0.0; pointer_data.pressure = 1.0; pointer_data.pressure_max = 1.0; packet-&gt;SetPointerData(pointer_index++, pointer_data); &#125; [_ongoingTouches removeAllObjects]; [_engine.get() dispatchPointerDataPacket:std::move(packet)]; &#125;&#125; 手势事件处理 核心代码为 dispatchTouches方法，将 Touches 分发给 Engine 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129// Dispatches the UITouches to the engine. Usually, the type of change of the touch is determined// from the UITouch's phase. However, FlutterAppDelegate fakes touches to ensure that touch events// in the status bar area are available to framework code. The change type (optional) of the faked// touch is specified in the second argument./// 将 Touches 分配给引擎- (void)dispatchTouches:(NSSet*)touches pointerDataChangeOverride:(flutter::PointerData::Change*)overridden_change event:(UIEvent*)event &#123; if (!_engine) &#123; return; &#125; const CGFloat scale = [UIScreen mainScreen].scale; auto packet = std::make_unique&lt;flutter::PointerDataPacket&gt;(touches.count); size_t pointer_index = 0; for (UITouch* touch in touches) &#123; CGPoint windowCoordinates = [touch locationInView:self.view]; flutter::PointerData pointer_data; pointer_data.Clear(); constexpr int kMicrosecondsPerSecond = 1000 * 1000; pointer_data.time_stamp = touch.timestamp * kMicrosecondsPerSecond; pointer_data.change = overridden_change != nullptr ? *overridden_change : PointerDataChangeFromUITouchPhase(touch.phase); pointer_data.kind = DeviceKindFromTouchType(touch); pointer_data.device = reinterpret_cast&lt;int64_t&gt;(touch); // Pointer will be generated in pointer_data_packet_converter.cc. pointer_data.pointer_identifier = 0; pointer_data.physical_x = windowCoordinates.x * scale; pointer_data.physical_y = windowCoordinates.y * scale; // Delta will be generated in pointer_data_packet_converter.cc. pointer_data.physical_delta_x = 0.0; pointer_data.physical_delta_y = 0.0; NSNumber* deviceKey = [NSNumber numberWithLongLong:pointer_data.device]; // Track touches that began and not yet stopped so we can flush them // if the view controller goes away. // 只处理 tracking starts 和 stops 事件 switch (pointer_data.change) &#123; case flutter::PointerData::Change::kDown: [_ongoingTouches addObject:deviceKey]; break; case flutter::PointerData::Change::kCancel: case flutter::PointerData::Change::kUp: [_ongoingTouches removeObject:deviceKey]; break; case flutter::PointerData::Change::kHover: case flutter::PointerData::Change::kMove: // We're only tracking starts and stops. break; case flutter::PointerData::Change::kAdd: case flutter::PointerData::Change::kRemove: // We don't use kAdd/kRemove. break; case flutter::PointerData::Change::kPanZoomStart: case flutter::PointerData::Change::kPanZoomUpdate: case flutter::PointerData::Change::kPanZoomEnd: // We don't send pan/zoom events here break; &#125; // pressure_min is always 0.0 if (@available(iOS 9, *)) &#123; // These properties were introduced in iOS 9.0. pointer_data.pressure = touch.force; pointer_data.pressure_max = touch.maximumPossibleForce; &#125; else &#123; pointer_data.pressure = 1.0; pointer_data.pressure_max = 1.0; &#125; // These properties were introduced in iOS 8.0 pointer_data.radius_major = touch.majorRadius; pointer_data.radius_min = touch.majorRadius - touch.majorRadiusTolerance; pointer_data.radius_max = touch.majorRadius + touch.majorRadiusTolerance; // These properties were introduced in iOS 9.1 if (@available(iOS 9.1, *)) &#123; pointer_data.tilt = M_PI_2 - touch.altitudeAngle; pointer_data.orientation = [touch azimuthAngleInView:nil] - M_PI_2; &#125; if (@available(iOS 13.4, *)) &#123; if (event != nullptr) &#123; pointer_data.buttons = (((event.buttonMask &amp; UIEventButtonMaskPrimary) &gt; 0) ? flutter::PointerButtonMouse::kPointerButtonMousePrimary : 0) | (((event.buttonMask &amp; UIEventButtonMaskSecondary) &gt; 0) ? flutter::PointerButtonMouse::kPointerButtonMouseSecondary : 0); &#125; &#125; packet-&gt;SetPointerData(pointer_index++, pointer_data); &#125; [_engine.get() dispatchPointerDataPacket:std::move(packet)];&#125;- (void)touchesBegan:(NSSet*)touches withEvent:(UIEvent*)event &#123; [self dispatchTouches:touches pointerDataChangeOverride:nullptr event:event];&#125;- (void)touchesMoved:(NSSet*)touches withEvent:(UIEvent*)event &#123; [self dispatchTouches:touches pointerDataChangeOverride:nullptr event:event];&#125;- (void)touchesEnded:(NSSet*)touches withEvent:(UIEvent*)event &#123; [self dispatchTouches:touches pointerDataChangeOverride:nullptr event:event];&#125;- (void)touchesCancelled:(NSSet*)touches withEvent:(UIEvent*)event &#123; [self dispatchTouches:touches pointerDataChangeOverride:nullptr event:event];&#125;- (void)forceTouchesCancelled:(NSSet*)touches &#123; flutter::PointerData::Change cancel = flutter::PointerData::Change::kCancel; [self dispatchTouches:touches pointerDataChangeOverride:&amp;cancel event:nullptr];&#125; 键盘事件处理，这块内容主要是键盘显示动画PlatformViews、FlutterBinaryMessenger、FlutterTextureRegistry、FlutterPluginRegistry 具体实现在 FlutterEngine 类中，后面会对 FlutterEngine 源码进行解析。 FlutterEngine 源码分析FlutterEngine 在 FlutterViewController 中初始化完成相关成员变量的配置。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455@interface FlutterEngineRegistrar : NSObject &lt;FlutterPluginRegistrar&gt;@property(nonatomic, assign) FlutterEngine* flutterEngine;- (instancetype)initWithPlugin:(NSString*)pluginKey flutterEngine:(FlutterEngine*)flutterEngine;@end@interface FlutterEngine () &lt;FlutterIndirectScribbleDelegate, FlutterTextInputDelegate, FlutterBinaryMessenger&gt;// Maintains a dictionary of plugin names that have registered with the engine. Used by// FlutterEngineRegistrar to implement a FlutterPluginRegistrar.@property(nonatomic, readonly) NSMutableDictionary* pluginPublications;@property(nonatomic, readonly) NSMutableDictionary&lt;NSString*, FlutterEngineRegistrar*&gt;* registrars;@property(nonatomic, readwrite, copy) NSString* isolateId;@property(nonatomic, copy) NSString* initialRoute;@property(nonatomic, retain) id&lt;NSObject&gt; flutterViewControllerWillDeallocObserver;@end@implementation FlutterEngine &#123; fml::scoped_nsobject&lt;FlutterDartProject&gt; _dartProject; std::shared_ptr&lt;flutter::ThreadHost&gt; _threadHost; std::unique_ptr&lt;flutter::Shell&gt; _shell; NSString* _labelPrefix; std::unique_ptr&lt;fml::WeakPtrFactory&lt;FlutterEngine&gt;&gt; _weakFactory; fml::WeakPtr&lt;FlutterViewController&gt; _viewController; fml::scoped_nsobject&lt;FlutterObservatoryPublisher&gt; _publisher; std::shared_ptr&lt;flutter::FlutterPlatformViewsController&gt; _platformViewsController; flutter::IOSRenderingAPI _renderingApi; std::shared_ptr&lt;flutter::ProfilerMetricsIOS&gt; _profiler_metrics; std::shared_ptr&lt;flutter::SamplingProfiler&gt; _profiler; // Channels 内置 Channels fml::scoped_nsobject&lt;FlutterPlatformPlugin&gt; _platformPlugin; fml::scoped_nsobject&lt;FlutterTextInputPlugin&gt; _textInputPlugin; fml::scoped_nsobject&lt;FlutterRestorationPlugin&gt; _restorationPlugin; fml::scoped_nsobject&lt;FlutterMethodChannel&gt; _localizationChannel; fml::scoped_nsobject&lt;FlutterMethodChannel&gt; _navigationChannel; fml::scoped_nsobject&lt;FlutterMethodChannel&gt; _restorationChannel; fml::scoped_nsobject&lt;FlutterMethodChannel&gt; _platformChannel; fml::scoped_nsobject&lt;FlutterMethodChannel&gt; _platformViewsChannel; fml::scoped_nsobject&lt;FlutterMethodChannel&gt; _textInputChannel; fml::scoped_nsobject&lt;FlutterBasicMessageChannel&gt; _lifecycleChannel; fml::scoped_nsobject&lt;FlutterBasicMessageChannel&gt; _systemChannel; fml::scoped_nsobject&lt;FlutterBasicMessageChannel&gt; _settingsChannel; fml::scoped_nsobject&lt;FlutterBasicMessageChannel&gt; _keyEventChannel; int64_t _nextTextureId; BOOL _allowHeadlessExecution; BOOL _restorationEnabled; FlutterBinaryMessengerRelay* _binaryMessenger; std::unique_ptr&lt;flutter::ConnectionCollection&gt; _connections;&#125; FlutterEngine 启动，主要做两件事情： createShell launchEngine 12345678910- (BOOL)runWithEntrypoint:(NSString*)entrypoint libraryURI:(NSString*)libraryURI initialRoute:(NSString*)initialRoute entrypointArgs:(NSArray&lt;NSString*&gt;*)entrypointArgs &#123; if ([self createShell:entrypoint libraryURI:libraryURI initialRoute:initialRoute]) &#123; [self launchEngine:entrypoint libraryURI:libraryURI entrypointArgs:entrypointArgs]; &#125; return _shell != nullptr;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475- (BOOL)createShell:(NSString*)entrypoint libraryURI:(NSString*)libraryURI initialRoute:(NSString*)initialRoute &#123; if (_shell != nullptr) &#123; FML_LOG(WARNING) &lt;&lt; \"This FlutterEngine was already invoked.\"; return NO; &#125; // 设置初始化路由 self.initialRoute = initialRoute; auto settings = [_dartProject.get() settings]; if (initialRoute != nil) &#123; self.initialRoute = initialRoute; &#125; else if (settings.route.empty() == false) &#123; self.initialRoute = [NSString stringWithCString:settings.route.c_str() encoding:NSUTF8StringEncoding]; &#125; FlutterView.forceSoftwareRendering = settings.enable_software_rendering; auto platformData = [_dartProject.get() defaultPlatformData]; SetEntryPoint(&amp;settings, entrypoint, libraryURI); // 初始化 _threadHost NSString* threadLabel = [FlutterEngine generateThreadLabel:_labelPrefix]; _threadHost = std::make_shared&lt;flutter::ThreadHost&gt;(); *_threadHost = [FlutterEngine makeThreadHost:threadLabel]; // Lambda captures by pointers to ObjC objects are fine here because the // create call is synchronous. // 设置 on_create_platform_view 回调 flutter::Shell::CreateCallback&lt;flutter::PlatformView&gt; on_create_platform_view = [self](flutter::Shell&amp; shell) &#123; [self recreatePlatformViewController]; return std::make_unique&lt;flutter::PlatformViewIOS&gt;( shell, self-&gt;_renderingApi, self-&gt;_platformViewsController, shell.GetTaskRunners()); &#125;; // 设置 on_create_rasterizer 回调 flutter::Shell::CreateCallback&lt;flutter::Rasterizer&gt; on_create_rasterizer = [](flutter::Shell&amp; shell) &#123; return std::make_unique&lt;flutter::Rasterizer&gt;(shell); &#125;; // 初始化 TaskRunners // engine 启动了四个 task runner platform、raster、ui、io，但并不一定对应四个线程 flutter::TaskRunners task_runners(threadLabel.UTF8String, // label fml::MessageLoop::GetCurrent().GetTaskRunner(), // platform _threadHost-&gt;raster_thread-&gt;GetTaskRunner(), // raster _threadHost-&gt;ui_thread-&gt;GetTaskRunner(), // ui _threadHost-&gt;io_thread-&gt;GetTaskRunner() // io ); _isGpuDisabled = [UIApplication sharedApplication].applicationState == UIApplicationStateBackground; // Create the shell. This is a blocking operation. // 创建 shell std::unique_ptr&lt;flutter::Shell&gt; shell = flutter::Shell::Create( /*platform_data=*/std::move(platformData), /*task_runners=*/std::move(task_runners), /*settings=*/std::move(settings), /*on_create_platform_view=*/on_create_platform_view, /*on_create_rasterizer=*/on_create_rasterizer, /*is_gpu_disabled=*/_isGpuDisabled); if (shell == nullptr) &#123; FML_LOG(ERROR) &lt;&lt; \"Could not start a shell FlutterEngine with entrypoint: \" &lt;&lt; entrypoint.UTF8String; &#125; else &#123; // 启动 isolate [self setupShell:std::move(shell) withObservatoryPublication:settings.enable_observatory_publication]; if ([FlutterEngine isProfilerEnabled]) &#123; [self startProfiler]; &#125; &#125; return _shell != nullptr;&#125; 启动 Engine，代码实现调用 shell 的 RunEngine 方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546- (void)launchEngine:(NSString*)entrypoint libraryURI:(NSString*)libraryOrNil entrypointArgs:(NSArray&lt;NSString*&gt;*)entrypointArgs &#123; // Launch the Dart application with the inferred run configuration. self.shell.RunEngine([_dartProject.get() runConfigurationForEntrypoint:entrypoint libraryOrNil:libraryOrNil entrypointArgs:entrypointArgs]);&#125;void Shell::RunEngine(RunConfiguration run_configuration) &#123; RunEngine(std::move(run_configuration), nullptr);&#125;void Shell::RunEngine( RunConfiguration run_configuration, const std::function&lt;void(Engine::RunStatus)&gt;&amp; result_callback) &#123; auto result = [platform_runner = task_runners_.GetPlatformTaskRunner(), result_callback](Engine::RunStatus run_result) &#123; if (!result_callback) &#123; return; &#125; platform_runner-&gt;PostTask( [result_callback, run_result]() &#123; result_callback(run_result); &#125;); &#125;; FML_DCHECK(is_setup_); FML_DCHECK(task_runners_.GetPlatformTaskRunner()-&gt;RunsTasksOnCurrentThread()); fml::TaskRunner::RunNowOrPostTask( task_runners_.GetUITaskRunner(), fml::MakeCopyable( [run_configuration = std::move(run_configuration), weak_engine = weak_engine_, result]() mutable &#123; if (!weak_engine) &#123; FML_LOG(ERROR) &lt;&lt; \"Could not launch engine with configuration - no engine.\"; result(Engine::RunStatus::Failure); return; &#125; // 启动 engine auto run_result = weak_engine-&gt;Run(std::move(run_configuration)); if (run_result == flutter::Engine::RunStatus::Failure) &#123; FML_LOG(ERROR) &lt;&lt; \"Could not launch engine with configuration.\"; &#125; result(run_result); &#125;));&#125; 核心实现为 engine.cc 里的 weak_engine-&gt;Run(std::move(run_configuration))，最终启动 isolate。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849Engine::RunStatus Engine::Run(RunConfiguration configuration) &#123; if (!configuration.IsValid()) &#123; FML_LOG(ERROR) &lt;&lt; \"Engine run configuration was invalid.\"; return RunStatus::Failure; &#125; last_entry_point_ = configuration.GetEntrypoint(); last_entry_point_library_ = configuration.GetEntrypointLibrary();#if (FLUTTER_RUNTIME_MODE == FLUTTER_RUNTIME_MODE_DEBUG) // This is only used to support restart. last_entry_point_args_ = configuration.GetEntrypointArgs();#endif UpdateAssetManager(configuration.GetAssetManager()); if (runtime_controller_-&gt;IsRootIsolateRunning()) &#123; return RunStatus::FailureAlreadyRunning; &#125; // If the embedding prefetched the default font manager, then set up the // font manager later in the engine launch process. This makes it less // likely that the setup will need to wait for the prefetch to complete. auto root_isolate_create_callback = [&amp;]() &#123; if (settings_.prefetched_default_font_manager) &#123; SetupDefaultFontManager(); &#125; &#125;; // 启动 root isolate if (!runtime_controller_-&gt;LaunchRootIsolate( settings_, // root_isolate_create_callback, // configuration.GetEntrypoint(), // configuration.GetEntrypointLibrary(), // configuration.GetEntrypointArgs(), // configuration.TakeIsolateConfiguration()) // ) &#123; return RunStatus::Failure; &#125; // 获取 isolate id auto service_id = runtime_controller_-&gt;GetRootIsolateServiceID(); if (service_id.has_value()) &#123; std::unique_ptr&lt;PlatformMessage&gt; service_id_message = std::make_unique&lt;flutter::PlatformMessage&gt;( kIsolateChannel, MakeMapping(service_id.value()), nullptr); HandlePlatformMessage(std::move(service_id_message)); &#125; return Engine::RunStatus::Success;&#125; 调用 runtime_controller``LaunchRootIsolate 方法 CreateRunningRootIsolate 创建并启动 isolate 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859bool RuntimeController::LaunchRootIsolate( const Settings&amp; settings, fml::closure root_isolate_create_callback, std::optional&lt;std::string&gt; dart_entrypoint, std::optional&lt;std::string&gt; dart_entrypoint_library, const std::vector&lt;std::string&gt;&amp; dart_entrypoint_args, std::unique_ptr&lt;IsolateConfiguration&gt; isolate_configuration) &#123; if (root_isolate_.lock()) &#123; FML_LOG(ERROR) &lt;&lt; \"Root isolate was already running.\"; return false; &#125; auto strong_root_isolate = DartIsolate::CreateRunningRootIsolate( settings, // isolate_snapshot_, // std::make_unique&lt;PlatformConfiguration&gt;(this), // DartIsolate::Flags&#123;&#125;, // root_isolate_create_callback, // isolate_create_callback_, // isolate_shutdown_callback_, // dart_entrypoint, // dart_entrypoint_library, // dart_entrypoint_args, // std::move(isolate_configuration), // context_, // spawning_isolate_.lock().get()) // .lock(); if (!strong_root_isolate) &#123; FML_LOG(ERROR) &lt;&lt; \"Could not create root isolate.\"; return false; &#125; // The root isolate ivar is weak. root_isolate_ = strong_root_isolate; // Capture by `this` here is safe because the callback is made by the dart // state itself. The isolate (and its Dart state) is owned by this object and // it will be collected before this object. strong_root_isolate-&gt;SetReturnCodeCallback( [this](uint32_t code) &#123; root_isolate_return_code_ = code; &#125;); if (auto* platform_configuration = GetPlatformConfigurationIfAvailable()) &#123; tonic::DartState::Scope scope(strong_root_isolate); platform_configuration-&gt;DidCreateIsolate(); if (!FlushRuntimeStateToIsolate()) &#123; FML_DLOG(ERROR) &lt;&lt; \"Could not set up initial isolate state.\"; &#125; &#125; else &#123; FML_DCHECK(false) &lt;&lt; \"RuntimeController created without window binding.\"; &#125; FML_DCHECK(Dart_CurrentIsolate() == nullptr); client_.OnRootIsolateCreated(); return true;&#125; 创建并启动 isolate CreateRootIsolate RunFromLibrary 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255std::weak_ptr&lt;DartIsolate&gt; DartIsolate::CreateRunningRootIsolate( const Settings&amp; settings, fml::RefPtr&lt;const DartSnapshot&gt; isolate_snapshot, std::unique_ptr&lt;PlatformConfiguration&gt; platform_configuration, Flags isolate_flags, fml::closure root_isolate_create_callback, const fml::closure&amp; isolate_create_callback, const fml::closure&amp; isolate_shutdown_callback, std::optional&lt;std::string&gt; dart_entrypoint, std::optional&lt;std::string&gt; dart_entrypoint_library, const std::vector&lt;std::string&gt;&amp; dart_entrypoint_args, std::unique_ptr&lt;IsolateConfiguration&gt; isolate_configuration, const UIDartState::Context&amp; context, const DartIsolate* spawning_isolate) &#123; if (!isolate_snapshot) &#123; FML_LOG(ERROR) &lt;&lt; \"Invalid isolate snapshot.\"; return &#123;&#125;; &#125; if (!isolate_configuration) &#123; FML_LOG(ERROR) &lt;&lt; \"Invalid isolate configuration.\"; return &#123;&#125;; &#125; isolate_flags.SetNullSafetyEnabled( isolate_configuration-&gt;IsNullSafetyEnabled(*isolate_snapshot)); isolate_flags.SetIsDontNeedSafe(isolate_snapshot-&gt;IsDontNeedSafe()); auto isolate = CreateRootIsolate(settings, // isolate_snapshot, // std::move(platform_configuration), // isolate_flags, // isolate_create_callback, // isolate_shutdown_callback, // context, // spawning_isolate // ) .lock(); if (!isolate) &#123; FML_LOG(ERROR) &lt;&lt; \"Could not create root isolate.\"; return &#123;&#125;; &#125; fml::ScopedCleanupClosure shutdown_on_error([isolate]() &#123; if (!isolate-&gt;Shutdown()) &#123; FML_DLOG(ERROR) &lt;&lt; \"Could not shutdown transient isolate.\"; &#125; &#125;); if (isolate-&gt;GetPhase() != DartIsolate::Phase::LibrariesSetup) &#123; FML_LOG(ERROR) &lt;&lt; \"Root isolate was created in an incorrect phase: \" &lt;&lt; static_cast&lt;int&gt;(isolate-&gt;GetPhase()); return &#123;&#125;; &#125; if (!isolate_configuration-&gt;PrepareIsolate(*isolate.get())) &#123; FML_LOG(ERROR) &lt;&lt; \"Could not prepare isolate.\"; return &#123;&#125;; &#125; if (isolate-&gt;GetPhase() != DartIsolate::Phase::Ready) &#123; FML_LOG(ERROR) &lt;&lt; \"Root isolate not in the ready phase for Dart entrypoint \" \"invocation.\"; return &#123;&#125;; &#125; if (settings.root_isolate_create_callback) &#123; // Isolate callbacks always occur in isolate scope and before user code has // had a chance to run. tonic::DartState::Scope scope(isolate.get()); settings.root_isolate_create_callback(*isolate.get()); &#125; if (root_isolate_create_callback) &#123; root_isolate_create_callback(); &#125; if (!isolate-&gt;RunFromLibrary(dart_entrypoint_library, // dart_entrypoint, // dart_entrypoint_args)) &#123; FML_LOG(ERROR) &lt;&lt; \"Could not run the run main Dart entrypoint.\"; return &#123;&#125;; &#125; if (settings.root_isolate_shutdown_callback) &#123; isolate-&gt;AddIsolateShutdownCallback( settings.root_isolate_shutdown_callback); &#125; shutdown_on_error.Release(); return isolate;&#125;// 1. CreateRootIsolatestd::weak_ptr&lt;DartIsolate&gt; DartIsolate::CreateRootIsolate( const Settings&amp; settings, fml::RefPtr&lt;const DartSnapshot&gt; isolate_snapshot, std::unique_ptr&lt;PlatformConfiguration&gt; platform_configuration, Flags flags, const fml::closure&amp; isolate_create_callback, const fml::closure&amp; isolate_shutdown_callback, const UIDartState::Context&amp; context, const DartIsolate* spawning_isolate) &#123; TRACE_EVENT0(\"flutter\", \"DartIsolate::CreateRootIsolate\"); // The child isolate preparer is null but will be set when the isolate is // being prepared to run. auto isolate_group_data = std::make_unique&lt;std::shared_ptr&lt;DartIsolateGroupData&gt;&gt;( std::shared_ptr&lt;DartIsolateGroupData&gt;(new DartIsolateGroupData( settings, // settings std::move(isolate_snapshot), // isolate snapshot context.advisory_script_uri, // advisory URI context.advisory_script_entrypoint, // advisory entrypoint nullptr, // child isolate preparer isolate_create_callback, // isolate create callback isolate_shutdown_callback // isolate shutdown callback ))); auto isolate_data = std::make_unique&lt;std::shared_ptr&lt;DartIsolate&gt;&gt;( std::shared_ptr&lt;DartIsolate&gt;(new DartIsolate( settings, // settings true, // is_root_isolate std::move(context) // context ))); DartErrorString error; Dart_Isolate vm_isolate = nullptr; auto isolate_flags = flags.Get(); IsolateMaker isolate_maker; if (spawning_isolate) &#123; isolate_maker = [spawning_isolate]( std::shared_ptr&lt;DartIsolateGroupData&gt;* isolate_group_data, std::shared_ptr&lt;DartIsolate&gt;* isolate_data, Dart_IsolateFlags* flags, char** error) &#123; return Dart_CreateIsolateInGroup( /*group_member=*/spawning_isolate-&gt;isolate(), /*name=*/(*isolate_group_data)-&gt;GetAdvisoryScriptEntrypoint().c_str(), /*shutdown_callback=*/ reinterpret_cast&lt;Dart_IsolateShutdownCallback&gt;( DartIsolate::SpawnIsolateShutdownCallback), /*cleanup_callback=*/ reinterpret_cast&lt;Dart_IsolateCleanupCallback&gt;( DartIsolateCleanupCallback), /*child_isolate_data=*/isolate_data, /*error=*/error); &#125;; &#125; else &#123; isolate_maker = [](std::shared_ptr&lt;DartIsolateGroupData&gt;* isolate_group_data, std::shared_ptr&lt;DartIsolate&gt;* isolate_data, Dart_IsolateFlags* flags, char** error) &#123; return Dart_CreateIsolateGroup( (*isolate_group_data)-&gt;GetAdvisoryScriptURI().c_str(), (*isolate_group_data)-&gt;GetAdvisoryScriptEntrypoint().c_str(), (*isolate_group_data)-&gt;GetIsolateSnapshot()-&gt;GetDataMapping(), (*isolate_group_data)-&gt;GetIsolateSnapshot()-&gt;GetInstructionsMapping(), flags, isolate_group_data, isolate_data, error); &#125;; &#125; vm_isolate = CreateDartIsolateGroup(std::move(isolate_group_data), std::move(isolate_data), &amp;isolate_flags, error.error(), isolate_maker); if (error) &#123; FML_LOG(ERROR) &lt;&lt; \"CreateRootIsolate failed: \" &lt;&lt; error.str(); &#125; if (vm_isolate == nullptr) &#123; return &#123;&#125;; &#125; std::shared_ptr&lt;DartIsolate&gt;* root_isolate_data = static_cast&lt;std::shared_ptr&lt;DartIsolate&gt;*&gt;(Dart_IsolateData(vm_isolate)); (*root_isolate_data) -&gt;SetPlatformConfiguration(std::move(platform_configuration)); return (*root_isolate_data)-&gt;GetWeakIsolatePtr();&#125;// 2. RunFromLibrarybool DartIsolate::RunFromLibrary(std::optional&lt;std::string&gt; library_name, std::optional&lt;std::string&gt; entrypoint, const std::vector&lt;std::string&gt;&amp; args) &#123; TRACE_EVENT0(\"flutter\", \"DartIsolate::RunFromLibrary\"); if (phase_ != Phase::Ready) &#123; return false; &#125; tonic::DartState::Scope scope(this); auto library_handle = library_name.has_value() &amp;&amp; !library_name.value().empty() ? ::Dart_LookupLibrary(tonic::ToDart(library_name.value().c_str())) : ::Dart_RootLibrary(); // 查找 entrypoint auto entrypoint_handle = entrypoint.has_value() &amp;&amp; !entrypoint.value().empty() ? tonic::ToDart(entrypoint.value().c_str()) : tonic::ToDart(\"main\"); if (!FindAndInvokeDartPluginRegistrant()) &#123; // TODO(gaaclarke): Remove once the framework PR lands that uses `--source` // to compile the Dart Plugin Registrant // (https://github.com/flutter/flutter/pull/100572). InvokeDartPluginRegistrantIfAvailable(library_handle); &#125; auto user_entrypoint_function = ::Dart_GetField(library_handle, entrypoint_handle); auto entrypoint_args = tonic::ToDart(args); // 调用 entrypoint 的函数，InvokeMainEntrypoint if (!InvokeMainEntrypoint(user_entrypoint_function, entrypoint_args)) &#123; return false; &#125; phase_ = Phase::Running; return true;&#125;// 1. start_main_isolate_function// 2. _runMainZoned[[nodiscard]] static bool InvokeMainEntrypoint( Dart_Handle user_entrypoint_function, Dart_Handle args) &#123; if (tonic::LogIfError(user_entrypoint_function)) &#123; FML_LOG(ERROR) &lt;&lt; \"Could not resolve main entrypoint function.\"; return false; &#125; Dart_Handle start_main_isolate_function = tonic::DartInvokeField(Dart_LookupLibrary(tonic::ToDart(\"dart:isolate\")), \"_getStartMainIsolateFunction\", &#123;&#125;); if (tonic::LogIfError(start_main_isolate_function)) &#123; FML_LOG(ERROR) &lt;&lt; \"Could not resolve main entrypoint trampoline.\"; return false; &#125; if (tonic::LogIfError(tonic::DartInvokeField( Dart_LookupLibrary(tonic::ToDart(\"dart:ui\")), \"_runMainZoned\", &#123;start_main_isolate_function, user_entrypoint_function, args&#125;))) &#123; FML_LOG(ERROR) &lt;&lt; \"Could not invoke the main entrypoint.\"; return false; &#125; return true;&#125; 由上面代码可以看出 engine 启动的整个流程，如下图所示： 在 FlutterEngine 创建 shell 时会创建 UI Task Runner、Platform Task Runne、IO Task Runner 及 Raster Task Runner 这四个 Task Runner，每个 Runner 分别会处理其对应的任务 thread_host 创建线程，负责不同的工作 12345678910111213141516171819202122232425ThreadHost::ThreadHost(const ThreadHostConfig&amp; host_config) : name_prefix(host_config.name_prefix) &#123; if (host_config.isThreadNeeded(ThreadHost::Type::Platform)) &#123; platform_thread = CreateThread(Type::Platform, host_config.platform_config, host_config); &#125; if (host_config.isThreadNeeded(ThreadHost::Type::UI)) &#123; ui_thread = CreateThread(Type::UI, host_config.ui_config, host_config); &#125; if (host_config.isThreadNeeded(ThreadHost::Type::RASTER)) &#123; raster_thread = CreateThread(Type::RASTER, host_config.raster_config, host_config); &#125; if (host_config.isThreadNeeded(ThreadHost::Type::IO)) &#123; io_thread = CreateThread(Type::IO, host_config.io_config, host_config); &#125; if (host_config.isThreadNeeded(ThreadHost::Type::Profiler)) &#123; profiler_thread = CreateThread(Type::Profiler, host_config.profiler_config, host_config); &#125;&#125; FlutterView 源码解析FlutterView 并没有太多功能，主要是两点： 初始化时传入 FlutterViewEngineDelegate 创建 flutter::drawLayer 实际上，从 FlutterViewController 代码创建的 FlutterView，可以看出实际上 FlutterViewEngineDelegate 是由 FlutterEngine 实现的。 1_flutterView.reset([[FlutterView alloc] initWithDelegate:_engine opaque:self.isViewOpaque]); 1234567891011121314151617@protocol FlutterViewEngineDelegate &lt;NSObject&gt;- (flutter::Rasterizer::Screenshot)takeScreenshot:(flutter::Rasterizer::ScreenshotType)type asBase64Encoded:(BOOL)base64Encode;- (std::shared_ptr&lt;flutter::FlutterPlatformViewsController&gt;&amp;)platformViewsController;/** * A callback that is called when iOS queries accessibility information of the Flutter view. * * This is useful to predict the current iOS accessibility status. For example, there is * no API to listen whether voice control is turned on or off. The Flutter engine uses * this callback to enable semantics in order to catch the case that voice control is * on. */- (void)flutterViewAccessibilityDidCall;@end 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 根据设备及系统版本决定用那种渲染 API 实现，CALayer/CAEAGLLayer/CAMetalLayer+ (Class)layerClass &#123; return flutter::GetCoreAnimationLayerClassForRenderingAPI( flutter::GetRenderingAPIForProcess(FlutterView.forceSoftwareRendering));&#125;- (void)drawLayer:(CALayer*)layer inContext:(CGContextRef)context &#123; TRACE_EVENT0(\"flutter\", \"SnapshotFlutterView\"); if (layer != self.layer || context == nullptr) &#123; return; &#125; // 获取 Flutter 渲染的数据源 auto screenshot = [_delegate takeScreenshot:flutter::Rasterizer::ScreenshotType::UncompressedImage asBase64Encoded:NO]; if (!screenshot.data || screenshot.data-&gt;isEmpty() || screenshot.frame_size.isEmpty()) &#123; return; &#125; NSData* data = [NSData dataWithBytes:const_cast&lt;void*&gt;(screenshot.data-&gt;data()) length:screenshot.data-&gt;size()]; fml::CFRef&lt;CGDataProviderRef&gt; image_data_provider( CGDataProviderCreateWithCFData(reinterpret_cast&lt;CFDataRef&gt;(data))); fml::CFRef&lt;CGColorSpaceRef&gt; colorspace(CGColorSpaceCreateDeviceRGB()); fml::CFRef&lt;CGImageRef&gt; image(CGImageCreate( screenshot.frame_size.width(), // size_t width screenshot.frame_size.height(), // size_t height 8, // size_t bitsPerComponent 32, // size_t bitsPerPixel, 4 * screenshot.frame_size.width(), // size_t bytesPerRow colorspace, // CGColorSpaceRef space static_cast&lt;CGBitmapInfo&gt;(kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big), // CGBitmapInfo bitmapInfo image_data_provider, // CGDataProviderRef provider nullptr, // const CGFloat* decode false, // bool shouldInterpolate kCGRenderingIntentDefault // CGColorRenderingIntent intent )); const CGRect frame_rect = CGRectMake(0.0, 0.0, screenshot.frame_size.width(), screenshot.frame_size.height()); CGContextSaveGState(context); CGContextTranslateCTM(context, 0.0, CGBitmapContextGetHeight(context)); CGContextScaleCTM(context, 1.0, -1.0); CGContextDrawImage(context, frame_rect, image); CGContextRestoreGState(context);&#125; 123456789101112131415161718192021222324252627IOSRenderingAPI GetRenderingAPIForProcess(bool force_software) &#123;#if TARGET_OS_SIMULATOR // 模拟器使用 CALayer if (force_software) &#123; return IOSRenderingAPI::kSoftware; &#125;#else if (force_software) &#123; FML_LOG(WARNING) &lt;&lt; \"The --enable-software-rendering is only supported on Simulator targets \" \"and will be ignored.\"; &#125;#endif // TARGET_OS_SIMULATOR#if SHELL_ENABLE_METAL // 如果可以使用 Metal 则使用 CAMetalLayer static bool should_use_metal = ShouldUseMetalRenderer(); if (should_use_metal) &#123; return IOSRenderingAPI::kMetal; &#125;#endif // SHELL_ENABLE_METAL // OpenGL will be emulated using software rendering by Apple on the simulator, so we use the // Skia software rendering since it performs a little better than the emulated OpenGL.#if TARGET_OS_SIMULATOR return IOSRenderingAPI::kSoftware;#else // 真机并且不使用 Metal，则默认使用 OpenGL ES CAEAGLLayer return IOSRenderingAPI::kOpenGLES;#endif // TARGET_OS_SIMULATOR&#125; 由此可见，FlutterVIew 其实就是提供了一个画布来显示渲染的内容，具体详细的渲染是由 FlutterEngine 来实现。 总结Flutter 运行于 iOS 之上，从源码层面看，总结如下： 复用了现有的三类 CALayer 来绘制界面，drawLayer 时会调用 takeScreenshot 来获取 Flutter 界面的光栅图。 Flutter 自身会创建一个完全独立的线程环境来运行，我们需要关注的是四个 TaskRunner，UI Task Runner、Platform Task Runner、Raster Task Runner、IO Task Runner。 Platform Task Runner，原生端跟 Flutter 的所有交互都会在 Platform Task Runner 进行处理。 FlutterViewController 将所有的手势交互相关的都转发给 FlutterEngine 。 Flutter 运行流程为了验证整个运行流程，我分别在上面所提到的一些方法设置断点进行调试，如下所示： 断点流程如下所示： 对整个 Flutter 运行的流程可以大致总结如下，主要是侧重在引擎侧，仅供参考： 创建 FlutterViewController 创建 FlutterView、创建 FlutterEngine 创建 shell 创建 Dart VM 寻找 DartLibrary 定位到 Entrypoint 创建 engine，传入 DartLibrary 和 Entrypoint RuntimeController LaunchRootIsolate 创建 isolate 启动 engine、 Dart VM 加载 DartLibrary，运行 dart 的 Entrypoint 截取 Dart UI 的界面并光栅化并绘制到 CALayer/CAMetalLayer/CAEAGLLayer","tags":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"http://orangeschen.cn/tags/FrontEnd/"},{"name":"Flutter","slug":"Flutter","permalink":"http://orangeschen.cn/tags/Flutter/"}]},{"title":"Flutter 书单列表推荐","date":"2022-08-08T12:07:19.000Z","path":"2022/08/08/flutter/flutter-books-list/","text":"笔者开发的时候都是在网上边看一些博客学习边开发的，对 Flutter 还没有一个比较完善的认识，开发的时候也是一直处于摸索阶段，最近就阅读了一些 Flutter 相关的书，想要系统全面的学习一下 Flutter，然后发现市面上的书大多数都是针对初学者的，主要是帮助开发者比较完善的了解 Flutter UI 层面的一些开发知识，最多涉及到 Framework 层的一些源码分析，其余都是比较简单的一些 API 使用的概念。以下就是我阅读的一些书，翻阅的这些书的时候，发现都是大同小异，所以就想写一篇文章进行总结推荐，给一些需要学习 Flutter 的开发者提供一些参考意见。 Flutter 基础与实战从入门到 App 跨平台开发 Flutter 技术入门与实战第2版 Flutter 跨平台开发入门与实战 Flutter 开发之旅从南到北 Flutter 开发实战详解 Flutter 内核源码剖析 这个列表的书籍我是按照从易➡️难来排序的，其实只有 《Flutter 开发之旅从南到北》和 《Flutter 开发实战详解》这两本书是我从头到尾仔细阅读完的，其余的我都是大概翻阅了下，只针对一些不同的章节重点去看。如果是完全零基础的且前端开发经验比较少的读者，推荐 《Flutter 基础与实战从入门到 App 跨平台开发》这本书，这本书感觉主要就是针对零基础的，属于手把手式教学，比较通俗易懂。如果是属于有一定前端开发基础但没有 Flutter 开发经验的，推荐 《Flutter 开发实战详解》 这本书，内容相对 《Flutter 开发之旅从南到北》更加完善，当然如果你已经有 《Flutter 开发之旅从南到北》这本书了的话，那就没必要再看 Flutter 开发实战详解》这本了。最后不用说啦，如果是要进阶的话，现在也就只有 《Flutter 内核源码剖析》这本书了，应该也是最难啃的一本书，不过这本书我还没看，所以也无法提供太多的建议。关于每一本书的简介，我在后面都有列出来，供大家参考。 Flutter 基础与实战从入门到 App 跨平台开发 书名 Flutter 基础与实战入门到 App 跨平台开发 作者 赵龙 出版时间 2021-01-01 简介 本书旨在帮助读者快速入门 Flutter、掌握 Flutter 开发技能，从而具备一定的 Flutter 跨平台开发能力 示例代码 https://github.com/zhaolongs/flutter_book_jixie 整本书内容主要涉及到的是 UI 层面的知识，这本书比较适合初学者，简单易懂，跟其他比较大的不同是这本书是彩印的，图文并茂，图片说明也很详细，属于手把手教学指导，基础内容比较全面且详细，各种 UI 布局及使用教程，解说详细，截图上也会有对应的说明标志。书中的截图主要就是一些示例的截图，关于一些内容相关的逻辑视图比较少，不方便加深记忆。不过可能也是因为，书本内容都比较简单，入门级别，没有太过深入的东西，属于工具书类别了。 Flutter 技术入门与实战第2版 书名 Flutter 技术入门与实战第2版 作者 亢少军 出版时间 2019-12-01 简介 本书由资深架构师撰写，详细讲解 Flutter 的基本概念和使用技巧。既有基础知识，又有丰富示例，并包括详细案例的操作步骤，实操性强。还有配套网站提供了完整案例代码和视频课程，可帮助读者轻松掌握基础知识，快速进入实战。 整本书内容主要涉及到的是 UI 层面的知识，适合初学者。内容比较简单，里面没有什么底层知识，主要是 UI 的使用等基础知识，入门级别。相对于其他入门级别的书，这本书说实话没有什么优势，属于比较普通的了，没发现什么亮点。 Flutter 跨平台开发入门与实战 书名 Flutter 跨平台开发入门与实战 作者 向治洪 出版时间 2021-01-01 简介 本书共 14 章，涵盖 Flutter 跨平台开发所需的各方面知识，循序渐进的讲解有助于读者更深入地学习 Flutter 知识 适合初学者观看，内容算是比较全面的，跟其他入门级图书差别不大，关于事件处理这一块内容和其他的对比稍微有些不同，其余差不多。作为入门书籍来说，算是比较全面的了，整本书的内容也没有很多，300页，总的来说没有什么太大的缺点。 Flutter 开发之旅从南到北 书名 Flutter 开发之旅从南到北 作者 杨加康 出版时间 2020-11-01 简介 本书主要讲述 Flutter 框架的核心技术，有助于读者深入理解 Flutter 技术的完整知识体系。 整本书没有太深的内容，有一些原理介绍，主要是涉及 Framework 层面的，未涉及引擎方面源码分析，入门级别，体系比较完整，有助于全面的理解 Flutter 完整的体系。 Flutter 开发实战详解 书名 Flutter 开发实战详解 作者 郭树煜 出版时间 2020-05-01 简介 《 Flutter 开发实战详解 》以实战为导向，由浅入深地介绍了 Flutter 开发过程中的基础体系、实战技巧和源码分析。通过本书，读者可以快速掌握 Flutter 的开发技能，并通过实战学习 Flutter 的源码设计。 示例代码 https://github.com/CarGuo/gsy_github_app_flutter 由浅入深地介绍了 Flutter 开发过程中的基础体系、实战技巧和源码分析，内容全面详细，相较与前面那几本，这本内容算是稍微深入一些的，涉及到 Framework 层源码分析，所以适合有一定 Flutter 开发的读者阅读。这本书是我看的比较仔细的一本了，是我认为看过的所有入门级别当中最好的一本书。 Flutter 内核源码剖析 书名 Flutter 内核源码剖析 作者 赵裕 出版时间 2022-01-01 简介 涉及源码的获取与构建，功能模块的实现以及 Flutter 应用的性能探测，监控和调优，横跨 Java、C++、Dart，覆盖 Flutter 1.0 和 2.0 版本。 这本书是在我的阅读清单里的，还没开始看，所以书的质量或者内容接受难易程度目前还是未知，不过这本算是市面上针对 Flutter 底层源码分析的唯一一本书了，想要进阶的话，还是推荐阅读这本书。 顾名思义，通过这本书的书名就知道这本书的内容涉及到源码层分析，适合对跨平台技术感兴趣的开发人员、前端开发人员、Android/iOS 开发人员，希望深入了解 Flutter 或有性能调优需求的开发人员，对移动端渲染框架感兴趣的开发人员，以及渴望深入了解 Flutter 底层实现的开发人员阅读。","tags":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"http://orangeschen.cn/tags/FrontEnd/"},{"name":"Flutter","slug":"Flutter","permalink":"http://orangeschen.cn/tags/Flutter/"}]},{"title":"React Hooks","date":"2021-05-18T12:58:55.000Z","path":"2021/05/18/front-end/react-hooks/","text":"钩子(hook)的作用组件尽量写成纯函数，如果需要外部功能和副作用，就用钩子把外部代码勾进来hook是React函数组件的副效应解决方案，用来为函数组件引入副效应 useState() 保存状态 useCOntext() 保存上下文 useRef() 保存引用","tags":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"http://orangeschen.cn/tags/FrontEnd/"}]},{"title":"React && Angular","date":"2021-05-18T12:58:55.000Z","path":"2021/05/18/front-end/react-and-angular/","text":"React 与 Angular","tags":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"http://orangeschen.cn/tags/FrontEnd/"}]},{"title":"React && Flutter","date":"2021-05-18T12:58:55.000Z","path":"2021/05/18/front-end/react-and-flutter/","text":"React 与 Flutter","tags":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"http://orangeschen.cn/tags/FrontEnd/"}]},{"title":"Clean Architecture","date":"2021-05-18T12:58:55.000Z","path":"2021/05/18/front-end/clean-architecture/","text":"最早在安卓应用上使用高层模块不应该依赖于低层模块抽象不应该依赖细节，细节应该依赖抽象","tags":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"http://orangeschen.cn/tags/FrontEnd/"}]},{"title":"Flutter Root Widget","date":"2021-05-17T16:00:00.000Z","path":"2021/05/18/front-end/root-widget/","text":"Flutter Root Widget","tags":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"http://orangeschen.cn/tags/FrontEnd/"}]},{"title":"Fish Redux","date":"2021-05-17T16:00:00.000Z","path":"2021/05/18/front-end/fish-redux/","text":"Flutter Fish Redux","tags":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"http://orangeschen.cn/tags/FrontEnd/"}]},{"title":"2020总结｜写给2021的自己","date":"2021-05-16T13:40:40.000Z","path":"2021/05/16/life/review-2020/","text":"就挺秃然的，养生口号喊起来，防止爆肝😭 引言2020是特殊的一年，地狱开端，‘活着就好’成了2020的slogon，果然今年注定是不平凡的一年。看大家到年底总会写一下年度总结，想了想，自己现在的记忆力是在逐渐衰减，还是很有必要记录一下这一年发生的事情，以此来鞭策以后的自己。 工作先总结工作吧，工作是2020一整年的大头。2019年11月12日加入的现在这家公司，怎么说呢，本来是作为iOS开发进来的，结果title是大前端开发工程师，emmmm 这其实也还好，毕竟自己当初也是想趁机了解了解前端的技术。公司前期工作氛围还是很愉快的，同事都很有趣，弹性工作制，虽然每天工作时长都10个小时以上，大小周，并没有觉得疲惫，反而觉得很充实。直到2020年后，人员开始变动，之前一直在做的app项目也终止了。开始转手小程序和前端开发，摸索到6月份时，人员再次发生变动，小组开始转向工程效能这块，主要做些基建类的工作，后续也主要在维护前端项目和迭代需求上，中途还接手了python爬虫的工作内容。这一年只能说技术深度倒没啥变化，广度倒是有一定的扩展了。在公司的角色感觉就是一块砖，哪里需要去哪里，有点晕头转向。 技术2020算是给我打开了新大门吧，接触到了很多新的技术，新语言。技术和语言接触的不少，但是真正拿下的却没有💔。 iOS RN混合开发，soucery模版代码使用，redux数据流 移动端、web端单元测试、e2e测试 CI流水线实现 docker镜像、k8s部署 angular、react前端开发技术 wepy、remax小程序开发框架 scrapy爬虫框架, mongoDB、kafka使用 GraphQL BFF层NestJS实现 A/B实验平台前后端开发（golang、mongoDB、gRPC、Ng-Alain) DDD领域驱动设计 沟通公司的流程其实是我过去所有公司中流程最完善的一家，项目开始需要经历-需求评审-故事点评估-排期-DogFooding-Demo会-提测-上线，整套流程在公司执行的算是比较完善的了，这样可以避免对工期的预估错误，以及上线之后暴露出各种问题。一定程度上可以减少开发的bug率和测试的压力。在这家公司也注重文档的编写和项目进度的跟踪，在开发过程中有问题会及时的抛出，会议也会敢于表述自己的看法，同时每两周会有举办一次技术分享，都挺锻炼人的。所以今年文档输出和语言表达能力都有一定的提升。 展望2020年虽然接触的东西多，但是都没有深入了解。2021年还是要持续保持学习，提升技术和编程思想，书在不停买，但是都搁置着😂。 停止购买新书，至少先将手上的书看完 刷算法题，leetcode上保持活跃度 尊重细节，开发中避免犯低级的细节错误 看相关源码，深入理解 生活2020因为疫情的来临，感觉过的飞快，眨眼就迎来2021，总有种错觉，除了工作，貌似2020没有留下什么明显的痕迹。但是想来还是有迹可循的，花呗账单每个月居高不下（也不知道买了啥），只能说在自己身上的投资越来越多了，希望自己能变的更好吧。 轨迹 年后回来首次经历线上办公，刚开始还好，久了发现上班时间其实更长（遇到问题放不下，会一直花时间去解决），相当于把工作带进了生活吧 年中之后公司人员开始变动，人员巨减之后，负面情绪爆棚，只能慢慢消化 跟同事组织了一次清远自驾游，漂流很嗨、很解压，清远鸡很好吃哈哈 国庆大学室友结婚（又当了一次伴娘），去了郑州、柳州，体验了一把空中飞人，行程真的是排满（人的精力是无限的，逼一逼就出来了） 斥巨资做了icl近视手术，终于摆脱了眼镜（计划是不戴眼镜之后会保持锻炼，结果不了了之） 沉浸式密逃、剧本杀体验了一次 剩下的就是不定时的ktv、聚餐了 旅行今年旅行只自驾去了一次清远漂流、泡温泉，比较远的就跑郑州（重游了下大学）、舞钢参加了婚礼，回了一趟家，其余时间一直都在深圳两点一线生活。护照上盖个戳的计划成功泡汤了。 学习断断续续，坚持不了多久又停下了😭，意志力一如既往的薄弱。本来计划考教资的，结果毫无意外延期了，还没开始就已然结束。 生活展望定几个小目标，虽然会打脸，毕竟梦想还是要有的 多读书多读书多读书（重要的事情说三遍） 夏季游泳还是要抓起来的 至少徒步一次 长途旅游至少一次（计划去重庆） 穿衣风格还是可以改变一下的，学会化妆（效果跟变脸一样的那种） 锻炼（跑步、keep都可） 使用云函数实现一个简单的小程序，并发布 结束语不管是工作还是生活，只要有突破，对于我来说就是有收获的，and一切都是为了成为更好的自己。","tags":[{"name":"Life","slug":"Life","permalink":"http://orangeschen.cn/tags/Life/"}]},{"title":"Metal图片渲染","date":"2018-05-08T16:00:00.000Z","path":"2018/05/09/metal-draw-picture/","text":"本章内容主要是在上一篇绘制三角形的基础上添加了图片渲染的功能，分别说明了使用Metal和MetalKit中创建纹理的方法。 1、首先修改Metal shader的着色里的内容 添加顶点输入和输出的结构体 123456789101112&#x2F;&#x2F; 输入的顶点和纹理坐标 struct VertexIn &#123; packed_float3 position; packed_float2 st; &#125;;&#x2F;&#x2F; 输出顶点和纹理坐标，因为需要渲染纹理，可以不用输入顶点颜色 struct VertexOut &#123; float4 position [[position]]; float2 st; &#125;; 顶点函数和片段函数内容 12345678910111213141516&#x2F;&#x2F; 添加纹理顶点坐标vertex VertexOut texture_vertex(uint vid[[vertex_id]], const device VertexIn *vertex_array[[buffer(0)]])&#123; VertexOut outVertex; VertexIn vertexIn &#x3D; vertex_array[vid]; outVertex.position &#x3D; float4(vertexIn.position, 1.0); outVertex.st &#x3D; vertexIn.st;&#x2F;&#x2F; outVertex.color &#x3D; color[vid]; return outVertex;&#125;;fragment float4 texture_fragment(VertextInOut inFrag[[stage_in]], texture2d&lt;float&gt; texas[[texture(0)]])&#123; constexpr sampler defaultSampler; float4 rgba &#x3D; texas.sample(defaultSampler, inFrag.st).rgba; return rgba;&#125;; 2、加载图片创建Metal纹理 Metal Framework中在处理贴图上使用CGImage在CGContext上draw的方法来取得图像, 但是通过draw方法绘制的图像是上下颠倒的。 首先要说的是，在iOS的不同framework中使用着不同的坐标系： UIKit － y轴向下 Core Graphics(Quartz) － y轴向上 OpenGL ES － y轴向上 UIKit是iPhone SDK的Cocoa Touch层的核心framework，是iPhone应用程序图形界面和事件驱动的基础，它和传统windows桌面一样，坐标系是y轴向下的; Core Graphics(Quartz)一个基于2D的图形绘制引擎，它的坐标系则是y轴向上的；而OpenGL ES是iPhone SDK的2D和3D绘制引擎，它使用左手坐标系，它的坐标系也是y轴向上的，如果不考虑z轴，在 二维下它的坐标系和Quartz是一样的。 注：不知道是不是API更新等原因，有小伙伴说图片倒置的问题还是存在，经过测试，发现CGContextDrawImage绘制的图片已经不需要处理倒置的问题了，具体原因还有待证实，或者说我这些观点有误的话希望有人能详细指出 以下内容可以忽略😆当通过CGContextDrawImage绘制图片到一个context中时，如果传入的是UIImage的CGImageRef，因为UIKit和CG坐标系y轴相反，所以图片绘制将会上下颠倒。解决方法有以下几种，解决方法一：在绘制到context前通过矩阵垂直翻转坐标系解决方法二：使用UIImage的drawInRect函数，该函数内部能自动处理图片的正确方向解决方法三：垂直翻转投影矩阵,这种方法通过设置上下颠倒的投影矩阵，使得原本y轴向上的GL坐标系看起来变成了y轴向下，并且坐标原点从屏幕左下角移到了屏幕左上角。如果你习惯使用y轴向下的坐标系进行二维操作，可以使用这种方法，同时原本颠倒的图片经过再次颠倒后回到了正确的方向： 本人能力有限，对于我来说矩阵的处理还是有难度的，所以选择第二种相对简单一些的方法来解决图片上下颠倒的问题。 新建Swift文件，引入头文件 123import Metalimport UIKitimport CoreGraphics 添加图片加载方法，调用makeTexture()方法生成纹理 1234567891011121314151617181920212223242526272829303132var type: MTLTextureType!var texture: MTLTexture!// 在处理贴图上使用CGImage在CGContext上draw的方法来取得图像, 但是通过draw方法绘制的图像是上下颠倒的，可以通过UIImage的drawInRect函数，该函数内部能自动处理图片的正确方向，生成纹理func loadIntoTextureWithDevice(device: MTLDevice, name: String, ext: String) -&gt; Bool &#123; let path = Bundle.main.path(forResource: name, ofType: ext) if !(path != nil) &#123; return false &#125; let image = UIImage(contentsOfFile: path!) let width = (image?.cgImage)!.width let height = (image?.cgImage)!.height let dataSize = width * height * 4 let data = UnsafeMutablePointer&lt;UInt8&gt;.allocate(capacity: dataSize) let colorSpace = CGColorSpaceCreateDeviceRGB() let context = CGContext(data: data, width: width, height: height, bitsPerComponent: 8, bytesPerRow: 4 * width, space: colorSpace, bitmapInfo: CGImageAlphaInfo.premultipliedLast.rawValue); context?.draw((image?.cgImage)!, in: CGRect(x: 0, y: 0, width: CGFloat(width), height: CGFloat(height))) // 通过UIImage的drawInRect函数，该函数内部能自动处理图片的正确方向 // 不知道是不是API更新了 已经不需要这一步处理图片方向了 // UIGraphicsPushContext(context!); // image?.draw(in: CGRect(x: 0, y: 0, width: CGFloat(width), height: CGFloat(height))) let textDes = MTLTextureDescriptor.texture2DDescriptor(pixelFormat: .rgba8Unorm, width: Int(width), height: Int(height), mipmapped: false) type = textDes.textureType texture = device.makeTexture(descriptor: textDes) if !(texture != nil) &#123; return false &#125; texture.replace(region: MTLRegionMake2D(0, 0, Int(width), Int(height)), mipmapLevel: 0, withBytes: context!.data!, bytesPerRow: width * 4) // UIGraphicsPopContext() free(data) return true&#125; MetalKit Framework则直接提供了MTKTextureLoader创建纹理 引入MetalKit头文件 12import Foundationimport MetalKit MTKTextureLoader加载图片创建纹理，MTKTextureLoader中提供了异步和同步加载的方法 1234567891011121314151617181920212223242526272829enum TextureError: Error &#123; case UIImageCreationError case MTKTextureLoaderError&#125;/*----------创建Metal纹理-------------- * @param device 设备 * @param name 图片名称 * @retun MTLTexture 纹理 */func makeTexture(device: MTLDevice, name: String) throws -&gt; MTLTexture &#123; guard let image = UIImage(named: name) else &#123; throw TextureError.UIImageCreationError &#125; // 处理后的图片是倒置，要先将其倒置过来才能显示出正图像, 或者修改纹理坐标，将纹理坐标左上角设置为(0,0)，这一步骤可以省略 let mirrorImage = UIImage(cgImage: (image.cgImage)!, scale: 1, orientation: UIImageOrientation.downMirrored) let scaledImage = UIImage.scaleToSize(mirrorImage, size: image.size) do &#123; let textureLoader = MTKTextureLoader(device: device) let textureLoaderOption:[String: NSNumber] = [ MTKTextureLoaderOptionSRGB: false] // 异步加载 // try textureLoader.newTexture(with: image.cgImage!, options: textureLoaderOption, completionHandler: &#123; (&lt;#MTLTexture?#&gt;, &lt;#Error?#&gt;) in // // &#125;) // 同步根据图片创建新的Metal纹理 // Synchronously loads image data and creates a new Metal texturefrom a given bitmap image. return try textureLoader.newTexture(with: scaledImage.cgImage!, options: textureLoaderOption) &#125;&#125; 123456789 // 自定义UIImage的类方法，设置图片大小extension UIImage &#123; class func scaleToSize(_ image: UIImage, size: CGSize)-&gt;UIImage &#123; UIGraphicsBeginImageContext(size) image.draw(in: CGRect(origin: CGPoint.zero, size: size)) let scaledImage = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return scaledImage! &#125; 3、获取纹理坐标，渲染图片 之前绘制三角形是使用顶点绘制的，这次使用索引绘制一个四边形。 添加纹理属性 1var quaTexture: MTLTexture! = nil 添加顶点buffer 1var indexBuffer: MTLBuffer! = nil 添加顶点和索引数组 123456789101112131415 // 3.1 在CPU创建一个浮点数数组，需要通过把它移动到一个MTLBuffer，来发送这些数据到GPU。 let vertexData:[Float] = [// 0.0, 1.0, 0.0,// -1.0, -1.0, 0.0,// 1.0, -1.0, 0.0 //position s, t -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1, ] let indices:[Int32] = [ 0, 1, 2, 0, 2, 3 ] 创建一个新的indexBuffer，存放索引数组 123 // 3.3 在GPU创建一个新的indexBuffer，存放索引数组，从CPU里输送data indexBuffer = device.makeBuffer(bytes: indices, length: indices.count * 4, options: MTLResourceOptions(rawValue: UInt(0)))indexBuffer.label = \"Indices\" 编译shader 1234// 6.1 通过调用device.newDefaultLibrary方法获得的MTLibrary对象访问到你项目中的预编译shaders,然后通过名字检索每个shaderlet defaultLibrary = device.newDefaultLibrary() let fragmentProgram = defaultLibrary?.makeFunction(name: \"texture_fragment\")let vertextProgram = defaultLibrary?.makeFunction(name: \"texture_vertex\") 加载纹理 12345678910111213// 加载纹理 // 1 使用Metal let loaded = loadTntoTextureWithDevice(device: device, name: \"lena\", ext: \"png\") if !loaded &#123; print(\"Failed to load texture\") &#125; quaTexture = texture// 2 使用MetalKit do &#123; quaTexture = try makeTexture(device: device, name: \"lena\") &#125; catch &#123; fatalError(\"Error: Can not load texture\") &#125; 在render方法中配置渲染命令编码器，调用setFragmentTexture添加纹理，drawIndexedPrimitives根据索引数组绘制图形。 123renderEncoder.setFragmentTexture(quaTexture, at: 0) // 根据索引画图renderEncoder.drawIndexedPrimitives(type: .triangle, indexCount: indices.count, indexType: .uint32, indexBuffer: indexBuffer, indexBufferOffset: 0) 最终效果图如图所示，对于这些原理的东西了解还不是很深，网上的资料太少，能力有限，只能琢磨一些简单的东西。 如果对Metal感兴趣的可以下载Metal Swift Demo, GitHub上偶然看到别人写的Demo，里面有纹理和矩阵，ModelIO和MetalKit的结合使用等例子。 最后献上Demo例子","tags":[{"name":"Metal","slug":"Metal","permalink":"http://orangeschen.cn/tags/Metal/"},{"name":"iOS","slug":"iOS","permalink":"http://orangeschen.cn/tags/iOS/"}]},{"title":"Metal实现YUV转RGB渲染视频","date":"2018-05-08T16:00:00.000Z","path":"2018/05/09/metal-yuv-to-rgb/","text":"本次例子使用的是AVFoundation提供的AVCaptureVideoDataOutput获取每一帧的CVPixelBufferRef，详细步骤就不说了，网上有很多例子，这篇文章主要是介绍Metal中实现YUV转RGB格式的一些主要步骤，和OpenGL中的步骤差不多，主要是API和着色器不同，思路是一样的，这篇文章适合熟悉OpenGL视频渲染和有Metal基础的人观看，代码就不一一注释了，主要是本人理解的也不是很深，怕误人子弟。（示例代码为横屏显示，所以看到的屏幕是横屏显示）源代码下载地址 1 首先是shader上的片元着色器转换YUV到RGB123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;metal_stdlib&gt;using namespace metal;#define YUV_SHADER_ARGS VertexOut inFrag [[ stage_in ]],\\texture2d&lt;float&gt; lumaTex [[ texture(0) ]],\\texture2d&lt;float&gt; chromaTex [[ texture(1) ]],\\sampler bilinear [[ sampler(0) ]], \\constant ColorParameters *colorParameters [[ buffer(0) ]]&#x2F;&#x2F; RGB到YUV的转换矩阵struct VertexIn&#123; packed_float3 position; packed_float4 color; packed_float2 st;&#125;;struct VertexOut&#123; float4 position [[position]]; &#x2F;&#x2F;1 float4 color; float2 st;&#125;;struct ColorParameters&#123; float3x3 yuvToRGB;&#125;;vertex VertexOut texture_vertex( const device VertexIn* vertex_array [[ buffer(0) ]], &#x2F;&#x2F;1 unsigned int vid [[ vertex_id ]]) &#123; VertexIn VertexIn &#x3D; vertex_array[vid]; VertexOut VertexOut; VertexOut.position &#x3D; float4(VertexIn.position,1); &#x2F;&#x2F;3 VertexOut.color &#x3D; VertexIn.color; VertexOut.st &#x3D; VertexIn.st; return VertexOut;&#125;fragment half4 yuv_rgb(YUV_SHADER_ARGS)&#123; float3 yuv; yuv.x &#x3D; lumaTex.sample(bilinear, inFrag.st).r; yuv.yz &#x3D; chromaTex.sample(bilinear,inFrag.st).rg - float2(0.5); return half4(half3(colorParameters-&gt;yuvToRGB * yuv),yuv.x);&#125; 2 添加纹理缓存CVMetalTextureCacheRef和纹理MTLTexture变量123CVMetalTextureCacheRef _videoTextureCache; id&lt;MTLTexture&gt; _videoTexture[2]; CVPixelBufferRef _pixelBuffer; 添加转换矩阵的接收变量 1@property (nonatomic, strong) id&lt;MTLBuffer&gt; parametersBuffer; 以下几个都是YUV转RGB的矩阵算法，给parametersBuffer赋值，拷贝到GPU中计算 12345678910111213141516171819202122232425262728293031323334353637383940414243444546_parametersBuffer = [_device newBufferWithLength:sizeof(ColorParameters) * 2 options:MTLResourceOptionCPUCacheModeDefault]; ColorParameters matrix; simd::float3 A; simd::float3 B; simd::float3 C; // 1 // A.x = 1; // A.y = 1; // A.z = 1; // // B.x = 0; // B.y = -0.343; // B.z = 1.765; // // C.x = 1.4; // C.y = -0.765; // C.z = 0; // 2 // A.x = 1.164; // A.y = 1.164; // A.z = 1.164; // // B.x = 0; // B.y = -0.392; // B.z = 2.017; // // C.x = 1.596; // C.y = -0.813; // C.z = 0; // 3 A.x = 1.164; A.y = 1.164; A.z = 1.164; B.x = 0; B.y = -0.231; B.z = 2.112; C.x = 1.793; C.y = -0.533; C.z = 0; matrix.yuvToRGB = simd::float3x3&#123;A, B, C&#125;; memcpy(self.parametersBuffer.contents, &amp;matrix, sizeof(ColorParameters)); 获取每一帧视频信息生成纹理的代码 123456789101112131415161718192021222324252627282930313233343536373839- (void)makeYUVTexture:(CVPixelBufferRef)pixelBuffer &#123; CVMetalTextureRef y_texture ; float y_width = CVPixelBufferGetWidthOfPlane(pixelBuffer, 0); float y_height = CVPixelBufferGetHeightOfPlane(pixelBuffer, 0); CVMetalTextureCacheCreateTextureFromImage(kCFAllocatorDefault, _videoTextureCache, pixelBuffer, nil, MTLPixelFormatR8Unorm, y_width, y_height, 0, &amp;y_texture); CVMetalTextureRef uv_texture; float uv_width = CVPixelBufferGetWidthOfPlane(pixelBuffer, 1); float uv_height = CVPixelBufferGetHeightOfPlane(pixelBuffer, 1); CVMetalTextureCacheCreateTextureFromImage(kCFAllocatorDefault, _videoTextureCache, pixelBuffer, nil, MTLPixelFormatRG8Unorm, uv_width, uv_height, 1, &amp;uv_texture); id&lt;MTLTexture&gt; luma = CVMetalTextureGetTexture(y_texture); id&lt;MTLTexture&gt; chroma = CVMetalTextureGetTexture(uv_texture); _videoTexture[0] = luma; _videoTexture[1] = chroma; CVBufferRelease(y_texture); CVBufferRelease(uv_texture);&#125;- (void)display:(CVPixelBufferRef)overlay &#123; if (!overlay) &#123; return; &#125; if (!_videoTextureCache) &#123; NSLog(@\"No video texture cache\"); return; &#125; [self makeYUVTexture:overlay];&#125;- (void)setVideoTexture &#123; CVMetalTextureCacheFlush(_videoTextureCache, 0); CVReturn err = CVMetalTextureCacheCreate(kCFAllocatorDefault, NULL, _device, NULL, &amp;_videoTextureCache); if (err) &#123; NSLog(@\"&gt;&gt; ERROR: Could not create a texture cache\"); assert(0); &#125;&#125; （最后PS： 有大神知道怎么使用Metal实现渲染到纹理的么，求指导）","tags":[{"name":"Metal","slug":"Metal","permalink":"http://orangeschen.cn/tags/Metal/"},{"name":"iOS","slug":"iOS","permalink":"http://orangeschen.cn/tags/iOS/"}]},{"title":"Metal入门（使用Metal画一个三角形）","date":"2018-05-01T16:00:00.000Z","path":"2018/05/02/metal-learn-base/","text":"学习使用苹果GPU加速3D绘图的新API:MetalMetal和OpenGL ES相似，它也是一个底层API，负责和3D绘图硬件交互。它们之间的不同在于，Metal不是跨平台的, Metal 是用 Objective-C 编 写的，基于 Foundation，使用 GCD 在 CPU 和 GPU 之间保持同步。与之相反的，它设计的在苹果硬件上运行得极其高效，与OpenGL ES相比，它提供了更快的速度和更低的开销。它是一个GPU上一个简单的封装，所以能够完成几乎所有事情，像在屏幕上渲染一个精灵（sprite）或者是一个3D模型。但你要编写完成这些事情的所有代码。这样麻烦的代价是，你拥有了GPU的力量和控制。优点：1、使硬件达到运行效率的峰值：因为Metal非常底层，它允许你使硬件达到运行效率的峰值，对你的游戏如何运行有着完全的控制。2、这是一个很好的学习经历：学习Metal教导你很多关于3D绘图编程的概念，编写你自己的游戏引擎，以及高层(higher level)游戏框架如何运作。 关于metal详细的介绍可参考: 以下是使用Metal和Swift来创建一个有基本脉络的应用：画一个简单的三角形注意：Metal应用不能跑在iOS模拟器上，它们需要一个设备，设备上装载着苹果A7芯片或者更新的芯片。所以需要一台这样的设备(iPhone 5S,iPad Air,iPad mini2)来完成代码的测试。打开Xcode 通过iOS\\Application\\Single View Application template创建一个新的项目。使用TriangleSwift作为项目名称，设置开发语言为Swift，设置设备为通用设备(Universal)。点击Next，选择一个目录，点击Create。有七个步骤来设置metal：1 创建一个MTLDevice2 创建一个CAMetalLayer3 创建一个Vertex Buffer4 创建一个Vertex Shader5 创建一个Fragment Shader6 创建一个Render Pipeline7 创建一个Command Queue 1 创建一个MTLDevice使用Metal你要做的第一件事就是获取一个MTLDevice的引用。为了完成这点，打开ViewController.swift 并添加下面的import语句 1import Metal 导入了Metal框架，所以你能够使用Metal的类（像这文件中的MTLDevice）。接着，在ViewController类中添加以下属性：在viewDidLoad函数内初始化这个属性 12// 1、创建一个MTLDevice, 你可以把一个MTLDevice想象成是你和CPU的直接连接。你将通过使用MTLDevice创建所有其他你需要的Metal对象（像是command queues，buffers，textures）。var device: MTLDevice! = nil 2 创建一个CAMetalLayer在iOS里，你在屏幕上看见的所有东西，被一个CALayer所承载。存在不同特效的CALayer的子类，比如：渐变层(gradient layers)、形状层（shapelayers）、重复层(replicator layers) 等等。如果你想要用Metal在屏幕上画一些东西，你需要使用一个特别的CALayer子类，CAMetalLayer。因为CAMetalLayer是QuartzCore框架的部分，而不是Metal框架里的，首先在这个文件的上方添加import语句 1import QuartzCore 把新属性添加到类中： 12// 2、创建一个CAMetalLayervar metalLayer: CAMetalLayer! = nil 设置metalLayer 123456789101112131415// 2.1 创建CAMetalLayermetalLayer = CAMetalLayer()// 2.2 必须明确layer使用的MTLDevice，简单地设置早前获取的devicemetalLayer.device = device// 2.3 把像素格式（pixel format）设置为BGRA8Unorm，它代表\"8字节代表蓝色、绿色、红色和透明度，通过在0到1之间单位化的值来表示\"。这次两种用在CAMetalLayer的像素格式之一，一般情况下你这样写就可以了。metalLayer.pixelFormat = .bgra8Unorm// 2.4 苹果鼓励将framebufferOnly设置为true，来增强表现效率。除非你需要对从layer生成的纹理（textures）取样，或者你需要在layer绘图纹理(drawable textures)激活一些计算内核，否则你不需要设置。（大部分情况下你不用设置）metalLayer.framebufferOnly = true// 2.5 把layer的frame设置为view的framemetalLayer.frame = view.layer.framevar drawableSize = self.view.bounds.sizedrawableSize.width *= self.view.contentScaleFactordrawableSize.height *= self.view.contentScaleFactormetalLayer.drawableSize = drawableSizeview.layer.addSublayer(metalLayer) 3 创建一个Vertex Buffer创建一个缓冲区。在你的类中添加下列的常量属性 12345678// 3、创建一个Vertex Buffervar vertexBuffer: MTLBuffer! = nil// 3.1 在CPU创建一个浮点数数组，需要通过把它移动到一个MTLBuffer，来发送这些数据到GPU。let vertexData:[Float] = [ 0.0, 1.0, 0.0, -1.0, -1.0, 0.0, 1.0, -1.0, 0.0] 在MTLDevice上调用makeBuffer(bytes:, length:, options:)，在GPU创建一个新的buffer，从CPU里输送data。options不能为空。 1234// 3.2 获取vertex data的字节大小。你通过把元素的大小和数组元素个数相乘来得到let dataSize = vertexData.count * 4// 3.3 在GPU创建一个新的buffer，从CPU里输送datavertexBuffer = device.makeBuffer(bytes: vertexData, length: dataSize, options: MTLResourceOptions(rawValue: UInt(0))) 4 创建一个Vertex Shader你之前创建的顶点将成为接下来写的一个叫vertext shader的小程序的输入。一个vertex shader 是一个在GPU上运行的小程序，它由像c++的一门语言编写，那门语言叫做Metal Shading Language。一个vertex shader被每个顶点调用，它的工作是接受顶点的信息（如：位置和颜色、纹理坐标），返回一个潜在的修正位置（可能还有别的相关信息）点击File\\New\\File，选择iOS\\Source\\Metal File，然后点击Next。输入Shader.metal作为文件名，然后点击Create。 1234567891011121314// 一个vertex shader被每个顶点调用，它的工作是接受顶点的信息（如：位置和颜色、纹理坐标），返回一个潜在的修正位置（可能还有别的相关信息）#include &lt;metal_stdlib&gt;using namespace metal;/** * 1、所有的vertex shaders必须以关键字vertex开头。函数必须至少返回顶点的最终位置——你通过指定float4（一个元素为4个浮点数的向量）。然后你给一个名字给vetex shader，以后你将用这个名字来访问这个vertex shader。 * 2、vertex shader会接受一个名叫vertex_id的属性的特定参数，它意味着它会被vertex数组里特定的顶点所装入。 * 3、一个指向一个元素为packed_float4(一个向量包含4个浮点数)的数组的指针，如：每个顶点的位置。这个 [[ ... ]] 语法被用在声明那些能被用作特定额外信息的属性，像是资源位置，shader输入，内建变量。这里你把这个参数用 [[ buffer(0) ]] 标记，来指明这个参数将会被在你代码中你发送到你的vertex shader的第一块buffer data所遍历。 * 4、基于vertex id来检索vertex数组中对应位置的vertex并把它返回。向量必须为一个float4类型vertex float4 basic_vertex ( constant packed_float3* vertex_array[[buffer(0)]], unsigned int vid[[vertex_id]])&#123; return float4(vertex_array[vid], 1.0);&#125; */ 5 创建一个Fragment Shader完成vertex shader后，另一个shader，它被每个在屏幕上的fragment(think pixel)调用，它就是fragment shader。fragment shader通过内插(interpolating)vertex shader的输出来获得自己的输入。 1234567/* 1. 所有fragment shaders必须以fragment关键字开始。这个函数必须至少返回fragment的最终颜色——你通过指定half4（一个颜色的RGBA值）来完成这个任务。注意，half4比float4在内存上更有效率，因为，你写入了更少的GPU内存。 2. 这里你返回(0.6,0.6,0.6,0.6)的颜色，也就是灰色。 */fragment half4 basic_fragment() &#123; return half4(0.6);&#125; 6 创建一个Render Pipeline现在你已经创建了一个vertex shader和一个fragment shader，你需要组合它们（加上一些配置数据）到一个特殊的对象，它名叫render pipeline。Metal的渲染器（shaders）是预编译的，render pipeline 配置会在你第一次设置它的时候被编译，所以所有事情都极其高效。首先在ViewController.swift里添加一个属性： 12// 6、创建一个Render Pipelinevar pipelineState: MTLRenderPipelineState! = nil 在viewDidLoad方法最后添加如下代码： 12345678// 6.1 通过调用device.newDefaultLibrary方法获得的MTLibrary对象访问到你项目中的预编译shaders,然后通过名字检索每个shader let defaultLibrary = device.newDefaultLibrary() let fragmentProgram = defaultLibrary?.makeFunction(name: \"basic_fragment\") let vertextProgram = defaultLibrary?.makeFunction(name: \"basic_vertex\") // 6.2 这里设置你的render pipeline。它包含你想要使用的shaders、颜色附件（color attachment）的像素格式(pixel format)。（例如：你渲染到的输入缓冲区，也就是CAMetalLayer） let pipelineStateDescriptor = MTLRenderPipelineDescriptor() pipelineStateDescriptor.vertexFunction = vertextProgram pipelineStateDescriptor.fragmentFunction = fragmentProgram pipelineStateDescriptor.colorAttachments[0].pixelFormat = .bgra8Unorm 7 创建一个Command Queue你需要做的最终的设置步骤，是创建一个MTLCommandQueue。把这个想象成是一个列表装载着你告诉GPU一次要执行的命令。要创建一个command queue，简单地添加一个属性： 12// 7、创建一个Command Queuevar commandQueue: MTLCommandQueue! = nil 把下面这行添加到viewDidLoad中： 12// 7.1 初始化commandQueuecommandQueue = device.makeCommandQueue() 预设置的代码到这里完成了。接下来就是渲染三角形了，它将需要在五个步骤来完成：1 创建一个Display link。2 创建一个Render Pass Descriptor3 创建一个Command Buffer4 创建一个Render Command Encoder5 提交Command Buffer的内容注意：理论上这个应用实际上不需要每帧渲染，因为三角形被绘制之后不会动。但是，大部分应用会有物体的移动，所以我们会那样做。 1 创建一个Display link在iOS平台上，通过CADisplayLink 类，可以创建一个函数在每次设备屏幕刷新的时候被调用，这样你就可以重绘屏幕。为了使用它，在类里添加一个新的属性： 12// 8、创建一个Display Linkvar timer: CADisplayLink! = nil 初始化timer 123// 8.1 初始化 timer，设置timer，让它每次刷新屏幕的时候调用一个名叫drawloop的方法timer = CADisplayLink(target: self, selector: #selector(ViewController.drawloop))timer.add(to: RunLoop.main, forMode: RunLoopMode.defaultRunLoopMode) 渲染的代码在render()中实现 12345678func render() &#123; //TODO&#125;func drawloop() &#123; self.render() &#125; 2 创建一个Render Pass Descriptor123456789// metal layer上调用nextDrawable() ，它会返回你需要绘制到屏幕上的纹理(texture)let drawable = metalLayer.nextDrawable()// 8、创建一个Render Pass Descriptor，配置什么纹理会被渲染到、clear color，以及其他的配置let renderPassDesciptor = MTLRenderPassDescriptor()renderPassDesciptor.colorAttachments[0].texture = drawable?.texture// 设置load action为clear，也就是说在绘制之前，把纹理清空renderPassDesciptor.colorAttachments[0].loadAction = .clear// 绘制的背景颜色设置为绿色renderPassDesciptor.colorAttachments[0].clearColor = MTLClearColorMake(0.0, 0.8, 0.5, 1.0) 3 创建一个Command Buffer一个command buffer包含一个或多个渲染指令（render commands）。 123// 9、创建一个Command Buffer// 你可以把它想象为一系列这一帧想要执行的渲染命令。注意在你提交command buffer之前，没有事情会真正发生，这样给你对事物在何时发生有一个很好的控制。let commandBuffer = commandQueue.makeCommandBuffer() 4 创建一个渲染命令编码器(Render Command Encoder)12345678910111213141516// 10、创建一个渲染命令编码器(Render Command Encoder) // 创建一个command encoder，并指定你之前创建的pipeline和顶点 let renderEncoder = commandBuffer.makeRenderCommandEncoder(descriptor: renderPassDesciptor) renderEncoder.setRenderPipelineState(pipelineState) renderEncoder.setVertexBuffer(vertexBuffer, offset: 0, at: 0) /** 绘制图形 - parameter type: 画三角形 - parameter vertexStart: 从vertex buffer 下标为0的顶点开始 - parameter vertexCount: 顶点数 - parameter instanceCount: 总共有1个三角形 */ renderEncoder.drawPrimitives(type: .triangle, vertexStart: 0, vertexCount: 3, instanceCount: 1) // 完成后，调用endEncoding() renderEncoder.endEncoding() 5 提交Command Buffer1234// 保证新纹理会在绘制完成后立即出现commandBuffer.present(drawable!)// 提交事务(transaction), 把任务交给GPUcommandBuffer.commit() 学习资料• 苹果Metal开发者文档，有很多文档、录像、样例代码的链接。• 苹果的Metal编程指导• 苹果的Metal Shading Language 指导• WWDC2014 Metal录像","tags":[{"name":"Metal","slug":"Metal","permalink":"http://orangeschen.cn/tags/Metal/"},{"name":"iOS","slug":"iOS","permalink":"http://orangeschen.cn/tags/iOS/"}]},{"title":"iOS-private-api-checker私有API检测工具使用详细步骤","date":"2018-04-01T16:00:00.000Z","path":"2018/04/02/private-api-checker/","text":"iOS-private-api-checker私有API检查详细步骤（涉及到 Python、Flask、sqlite 环境）1、下载iOS-private-api-checker-master https://github.com/hustcc/iOS-private-api-checker 2、下载已经build好的ios_private.db库(本人能力有限，不会build，这个是大神build好的，sdk7.0版本，不是最新的，所以有些私有库查不出来(PS: 或者有些已经公开的库检测为私有库！！详情请看上面的链接，github上有教程，写这篇文章主要是想尝试一下如何使用这个工具，准确性不敢保证)，github上有教程，有能力的可以自己build^^)，将 ios_private.db 放入到项目的根目录，主要修改可写权限； （备注：ios_private.db 下载地址： 链接: https://pan.baidu.com/s/1d7YlSa 密码: fimx） 3、在根目录创建一个 tmp 目录（如果没有的话，注意修改可写权限），或者将tmp的文件夹的权限设置为777，先进terminal，然后输入Wally的命令，后面添加你的目录名。 1sudo chmod -R 777 目录名 4、在终端输入sqlite3 , 出现这个表示已经安装了sqlite，没有则参考 http://www.runoob.com/sqlite/sqlite-installation.html 进行安装 安装sqlite5、配置flask环境 5.1 Mac系统已经默认安装好了Python 2.7 5.2 安装python的包管理器pip ，先下载 get-pip.py ： https://bootstrap.pypa.io/get-pip.py 执行安装命令 1sudo python get-pip.py 5.3 安装virtualenv，virtualenv 为每个不同项目提供一份 Python 安装。它并没有真正安装多个 Python 副本，但是它确实提供了一种巧妙的方式来让各项目环境保持独立。 1sudo pip install virtualenv 5.4 开始配置flask环境 1234567891011进到项目目录$ cd 项目路径创建flask文件夹$ virtualenv flask$ cd flask激活环境$ source bin/activate安装flask$ pip install flask回到根目录$ cd - 6 、安装 macholib 1pip install macholib 7、最后运行 run_web（或者 ） 1python run_web.py 在浏览器中输入127.0.0.1:9527 将ipa拖入上传框等待即可看到检查结果","tags":[{"name":"iOS","slug":"iOS","permalink":"http://orangeschen.cn/tags/iOS/"}]},{"title":"Hello World","date":"2017-11-08T13:40:40.000Z","path":"2017/11/08/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]